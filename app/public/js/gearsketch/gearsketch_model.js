// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var ArcSegment, Board, Chain, Game, Gear, GraphNode, LineSegment, Point, Rule, Util, ValidationInput, ValidationResult,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Point = window.gearsketch.Point;

  ArcSegment = window.gearsketch.ArcSegment;

  LineSegment = window.gearsketch.LineSegment;

  Util = window.gearsketch.Util;

  window.gearsketch.model = {};

  Gear = (function() {
    function Gear(location1, rotation, numberOfTeeth, id3, momentum1, group3, level3, connections1, rpm, initialRpm, arrowHead) {
      this.location = location1;
      this.rotation = rotation;
      this.numberOfTeeth = numberOfTeeth;
      this.id = id3;
      this.momentum = momentum1 != null ? momentum1 : 0;
      this.group = group3 != null ? group3 : 0;
      this.level = level3 != null ? level3 : 0;
      this.connections = connections1 != null ? connections1 : {};
      this.rpm = rpm != null ? rpm : 0;
      this.initialRpm = initialRpm != null ? initialRpm : 0;
      this.arrowHead = arrowHead != null ? arrowHead : null;
      if (this.id == null) {
        this.id = Util.createUUID();
      }
      this.pitchRadius = Util.MODULE * (0.5 * this.numberOfTeeth);
      this.innerRadius = Util.MODULE * (0.5 * this.numberOfTeeth - 1.25);
      this.outerRadius = Util.MODULE * (0.5 * this.numberOfTeeth + 1);
      if (this.initialRpm) {
        this.momentum = this.initialRpm * 2 * Math.PI / 60;
      }
    }

    Gear.prototype.getCircumference = function() {
      return 2 * Math.PI * this.pitchRadius;
    };

    Gear.prototype.distanceToPoint = function(point) {
      return Math.max(0, this.location.distance(point) - this.pitchRadius);
    };

    Gear.prototype.edgeDistance = function(gear) {
      var axisDistance;
      axisDistance = this.location.distance(gear.location);
      return Math.abs(axisDistance - this.pitchRadius - gear.pitchRadius);
    };

    Gear.prototype.restore = function(gear) {
      this.location = gear.location;
      this.rotation = gear.rotation;
      this.momentum = gear.momentum;
      this.group = gear.group;
      this.level = gear.level;
      return this.connections = gear.connections;
    };

    Gear.prototype.clone = function() {
      return new Gear(this.location.clone(), this.rotation, this.numberOfTeeth, this.id, this.momentum, this.group, this.level, Util.clone(this.connections), this.rpm, this.initialRpm);
    };

    Gear.fromObject = function(obj) {
      return new Gear(Point.fromObject(obj.location), obj.rotation, obj.numberOfTeeth, obj.id, obj.momentum, obj.group, obj.level, obj.connections, obj.rpm, obj.rpm);
    };

    return Gear;

  })();

  window.gearsketch.model.Gear = Gear;

  Chain = (function() {
    Chain.WIDTH = 8;

    Chain.prototype.points = [];

    Chain.prototype.segments = [];

    function Chain(stroke, id3, group3, level3, connections1) {
      this.id = id3;
      this.group = group3 != null ? group3 : 0;
      this.level = level3 != null ? level3 : 0;
      this.connections = connections1 != null ? connections1 : {};
      if (this.id == null) {
        this.id = Util.createUUID();
      }
      this.points = Util.clone(stroke);
      this.rotation = 0;
    }

    Chain.prototype.getLength = function() {
      return this.segments.reduce((function(total, segment) {
        return total + segment.getLength();
      }), 0);
    };

    Chain.prototype.getCircumference = function() {
      return this.getLength();
    };

    Chain.prototype.getStartingPoint = function() {
      if (this.direction === Util.Direction.CLOCKWISE) {
        return this.rotation / (2 * Math.PI) * this.getLength();
      } else {
        return -this.rotation / (2 * Math.PI) * this.getLength();
      }
    };

    Chain.prototype.findPointOnChain = function(distance) {
      var distanceToGo, l, len, length, ref, segment, segmentLength;
      length = this.getLength();
      distanceToGo = Util.mod(distance + this.getStartingPoint(), length);
      ref = this.segments;
      for (l = 0, len = ref.length; l < len; l++) {
        segment = ref[l];
        segmentLength = segment.getLength();
        if (distanceToGo < segmentLength) {
          return segment.findPoint(distanceToGo);
        } else {
          distanceToGo -= segmentLength;
        }
      }
      return null;
    };

    Chain.prototype.findPointsOnChain = function(numberOfPoints) {
      var delta, l, p, ref, results;
      delta = this.getLength() / numberOfPoints;
      results = [];
      for (p = l = 0, ref = numberOfPoints; 0 <= ref ? l < ref : l > ref; p = 0 <= ref ? ++l : --l) {
        results.push(this.findPointOnChain(p * delta));
      }
      return results;
    };

    Chain.prototype.distanceToPoint = function(point) {
      var segment;
      return Math.min.apply(null, (function() {
        var l, len, ref, results;
        ref = this.segments;
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          segment = ref[l];
          results.push(segment.distanceToPoint(point));
        }
        return results;
      }).call(this));
    };

    Chain.prototype.distanceToSegment = function(s) {
      var segment;
      return Math.min.apply(null, (function() {
        var l, len, ref, results;
        ref = this.segments;
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          segment = ref[l];
          results.push(segment.distanceToSegment(s));
        }
        return results;
      }).call(this));
    };

    Chain.prototype.distanceToChain = function(chain) {
      var segment;
      return Math.min.apply(null, (function() {
        var l, len, ref, results;
        ref = this.segments;
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          segment = ref[l];
          results.push(chain.distanceToSegment(segment));
        }
        return results;
      }).call(this));
    };

    Chain.prototype.intersectsPath = function(path) {
      var i, j, l, ref;
      for (i = l = 0, ref = path.length - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        j = i + 1;
        if (this.distanceToSegment(new LineSegment(path[i], path[j])) === 0) {
          return true;
        }
      }
      return false;
    };

    Chain.prototype.crossesNonSupportingGears = function(board) {
      var gear, id, ref;
      ref = board.getGears();
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        gear = ref[id];
        if (!(indexOf.call(this.supportingGearIds, id) >= 0) && !(id in this.ignoredGearIds)) {
          if (this.distanceToPoint(gear.location) < gear.pitchRadius + Util.EPSILON) {
            return true;
          }
        }
      }
      return false;
    };

    Chain.prototype.findPointOnSupportingGear = function(gearIndex, incoming) {
      if (incoming) {
        return this.points[Util.mod(2 * gearIndex - 1, this.points.length)];
      } else {
        return this.points[2 * gearIndex];
      }
    };

    Chain.prototype.removeGear = function(gear, board) {
      var acknowledgedGears, afterIndex, beforeGear, beforeIndex, g, gears, index, numberOfGears, path, replacementGears;
      while ((index = this.supportingGearIds.indexOf(gear.id)) !== -1) {
        gears = board.getGearsWithIds(this.supportingGearIds);
        numberOfGears = gears.length;
        beforeIndex = Util.mod(index - 1, numberOfGears);
        beforeGear = gears[beforeIndex];
        afterIndex = Util.mod(index + 1, numberOfGears);
        acknowledgedGears = board.getAcknowledgedGears(this.ignoredGearIds);
        path = [this.findPointOnSupportingGear(index, true), this.findPointOnSupportingGear(index, false), this.findPointOnSupportingGear(afterIndex, true)];
        replacementGears = this.findSupportingGearsOnPath(acknowledgedGears, beforeGear, path, 0, false);
        gears.splice.apply(gears, [index, 1].concat(replacementGears));
        this.removeRepeatedGears(gears);
        this.supportingGearIds = (function() {
          var l, len, results;
          results = [];
          for (l = 0, len = gears.length; l < len; l++) {
            g = gears[l];
            results.push(g.id);
          }
          return results;
        })();
      }
      return this.update(board);
    };

    Chain.prototype.findChainTangentSide = function(gear) {
      if ((this.direction === Util.Direction.CLOCKWISE) === (gear.id in this.innerGearIds)) {
        return Util.Side.LEFT;
      } else {
        return Util.Side.RIGHT;
      }
    };

    Chain.prototype.findReverseChainTangentSide = function(gear) {
      if (this.findChainTangentSide(gear) === Util.Side.LEFT) {
        return Util.Side.RIGHT;
      } else {
        return Util.Side.LEFT;
      }
    };

    Chain.prototype.findFirstSupportingGearOnPath = function(path, gears) {
      var a, b, d, pathLength, stepSize, supportingGear;
      stepSize = 10;
      pathLength = Util.getLength(path);
      supportingGear = null;
      a = path[0];
      d = 0;
      while (d < pathLength && (supportingGear == null)) {
        d += stepSize;
        b = Util.findPointOnPath(path, d);
        supportingGear = Util.findNearestIntersectingGear(gears, new LineSegment(a, b));
      }
      return [supportingGear, d];
    };

    Chain.prototype.findSupportingGearsOnPath = function(gears, firstSupportingGear, path, startDistance, isClosed) {
      var a, b, d, lineSegment, nextSupportingGear, pathLength, stepSize, supportingGear, supportingGears, tangentPoint, tangentSide;
      if (startDistance == null) {
        startDistance = 0;
      }
      if (isClosed == null) {
        isClosed = true;
      }
      stepSize = 10;
      pathLength = Util.getLength(path, isClosed);
      supportingGear = firstSupportingGear;
      supportingGears = [];
      a = firstSupportingGear.location;
      d = startDistance;
      while (d < pathLength) {
        d += stepSize;
        b = Util.findPointOnPath(path, d);
        tangentSide = this.findReverseChainTangentSide(supportingGear);
        tangentPoint = Util.findGearTangentPoints(b, supportingGear)[tangentSide];
        if (tangentPoint != null) {
          a = tangentPoint;
        }
        lineSegment = new LineSegment(a, b);
        nextSupportingGear = Util.findNearestIntersectingGear(gears, lineSegment, Util.makeSet(supportingGear.id));
        if (nextSupportingGear != null) {
          supportingGear = nextSupportingGear;
          supportingGears.push(supportingGear);
        }
      }
      return supportingGears;
    };

    Chain.prototype.removeRepeatedGears = function(gearsList) {
      var g1, g2, i, j, numberOfGears, numberOfNoops;
      numberOfNoops = 0;
      i = 0;
      while (numberOfNoops < (numberOfGears = gearsList.length)) {
        j = (i + 1) % numberOfGears;
        g1 = gearsList[i];
        g2 = gearsList[j];
        if (g1 === g2) {
          gearsList.splice(j, 1);
          numberOfNoops = 0;
        } else {
          numberOfNoops++;
          i = (i + 1) % numberOfGears;
        }
      }
      return gearsList;
    };

    Chain.prototype.containsSuccessiveOverlappingGears = function(gearsList) {
      var g1, g2, i, j, l, numberOfGears, ref;
      numberOfGears = gearsList.length;
      for (i = l = 0, ref = numberOfGears; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        j = (i + 1) % numberOfGears;
        g1 = gearsList[i];
        g2 = gearsList[j];
        if (g1.location.distance(g2.location) < (g1.outerRadius + g2.outerRadius)) {
          return true;
        }
      }
      return false;
    };

    Chain.prototype.findSupportingGearIds = function(gears) {
      var finalSegment, firstSupportingGear, gear, l, lastSupportingGear, len, nextSupportingGears, ref, ref1, results, startDistance, supportingGears, tangentPoint, tangentSide;
      ref = this.findFirstSupportingGearOnPath(this.points, gears), firstSupportingGear = ref[0], startDistance = ref[1];
      supportingGears = [firstSupportingGear];
      nextSupportingGears = this.findSupportingGearsOnPath(gears, firstSupportingGear, this.points, startDistance);
      supportingGears = supportingGears.concat(nextSupportingGears);
      tangentSide = this.findChainTangentSide(firstSupportingGear);
      tangentPoint = Util.findGearTangentPoints(this.points[0], firstSupportingGear)[tangentSide];
      if (tangentPoint != null) {
        finalSegment = [this.points[0], tangentPoint];
        lastSupportingGear = supportingGears[supportingGears.length - 1];
        nextSupportingGears = this.findSupportingGearsOnPath(gears, lastSupportingGear, finalSegment, 0, false);
        supportingGears = supportingGears.concat(nextSupportingGears);
      }
      ref1 = this.removeRepeatedGears(supportingGears);
      results = [];
      for (l = 0, len = ref1.length; l < len; l++) {
        gear = ref1[l];
        results.push(gear.id);
      }
      return results;
    };

    Chain.prototype.findIgnoredGearIds = function(board) {
      var acknowledgedLevels, currentDistance, currentLevel, d, distance, gear, gears, group, id, ignoredGearIds, level, levels, minDistances, ref;
      gears = board.getGears();
      minDistances = {};
      for (id in gears) {
        if (!hasProp.call(gears, id)) continue;
        gear = gears[id];
        group = gear.group;
        level = gear.level;
        d = Util.pointPathDistance(gear.location, this.points) - gear.pitchRadius;
        if ((((ref = minDistances[group]) != null ? ref[level] : void 0) == null) || d < minDistances[group][level]) {
          if (minDistances[group] == null) {
            minDistances[group] = {};
          }
          minDistances[group][level] = d;
        }
      }
      acknowledgedLevels = {};
      for (group in minDistances) {
        if (!hasProp.call(minDistances, group)) continue;
        levels = minDistances[group];
        for (level in levels) {
          if (!hasProp.call(levels, level)) continue;
          distance = levels[level];
          currentLevel = acknowledgedLevels[group];
          if (currentLevel == null) {
            acknowledgedLevels[group] = parseInt(level, 10);
          } else if (distance > 0) {
            currentDistance = minDistances[group][currentLevel];
            if (currentDistance < 0 || distance < currentDistance) {
              acknowledgedLevels[group] = parseInt(level, 10);
            }
          }
        }
      }
      ignoredGearIds = {};
      for (id in gears) {
        if (!hasProp.call(gears, id)) continue;
        gear = gears[id];
        if (acknowledgedLevels[gear.group] !== gear.level) {
          ignoredGearIds[id] = true;
        }
      }
      return ignoredGearIds;
    };

    Chain.prototype.findIgnoredGearIdsInTightenedChain = function(board) {
      var gear, gearId, group, groups, id, l, len, level, ref, ref1, updatedIgnoredGearIds;
      groups = {};
      ref = this.supportingGearIds;
      for (l = 0, len = ref.length; l < len; l++) {
        gearId = ref[l];
        gear = board.getGearWithId(gearId);
        group = gear.group;
        level = gear.level;
        if (groups[group] == null) {
          groups[group] = {};
        }
        groups[group][level] = true;
      }
      updatedIgnoredGearIds = {};
      ref1 = board.getGears();
      for (id in ref1) {
        if (!hasProp.call(ref1, id)) continue;
        gear = ref1[id];
        group = gear.group;
        level = gear.level;
        if ((groups[group] != null) && (groups[group][level] == null)) {
          updatedIgnoredGearIds[id] = true;
        }
      }
      return this.ignoredGearIds = updatedIgnoredGearIds;
    };

    Chain.prototype.toPolygon = function(segments) {
      var l, len, polygon, segment;
      if (segments == null) {
        segments = this.segments;
      }
      polygon = [];
      for (l = 0, len = segments.length; l < len; l++) {
        segment = segments[l];
        if (segment instanceof LineSegment) {
          polygon.push(segment.start);
        } else {
          polygon.push(segment.findPoint(0));
          polygon.push(segment.findPoint(0.5 * segment.getLength()));
        }
      }
      return polygon;
    };

    Chain.prototype.update = function(board, gears) {
      var acknowledgedGears, arcEnd, arcSegment, arcStart, chainPolygon, direction, g1, g2, g3, gear, gearId, i, id, intersection, j, k, l, lineSegment, lineSegment1, lineSegment2, m, middleSegment, n, numberOfGears, numberOfSegments, o, p0, p1, p2, path, ref, ref1, ref2, ref3, ref4, ref5, replacementGears, s1, s2, tangentLine, tangentPointG1, tangentPointG3, tangentSideG1, tangentSideG3, updatedAcknowledgedGears, updatedIgnoredGearIds, updatedInnerGearIds, updatedPoints, updatedSegments;
      if (gears == null) {
        gears = board.getGearsWithIds(this.supportingGearIds);
      }
      if (gears.length < 2) {
        return false;
      }
      if (this.containsSuccessiveOverlappingGears(gears)) {
        return false;
      }
      updatedIgnoredGearIds = this.findIgnoredGearIdsInTightenedChain(board);
      acknowledgedGears = board.getAcknowledgedGears(updatedIgnoredGearIds);
      i = 0;
      while (i < (numberOfGears = gears.length)) {
        j = (i + 1) % numberOfGears;
        k = (i + 2) % numberOfGears;
        g1 = gears[i];
        g2 = gears[j];
        g3 = gears[k];
        lineSegment1 = Util.findTangentLine(g1, g2, this.innerGearIds, this.direction);
        lineSegment2 = Util.findTangentLine(g2, g3, this.innerGearIds, this.direction);
        intersection = lineSegment1.findIntersection(lineSegment2);
        if (intersection != null) {
          tangentSideG1 = this.findReverseChainTangentSide(g1);
          tangentPointG1 = Util.findGearTangentPoints(intersection, g1)[tangentSideG1];
          tangentSideG3 = this.findChainTangentSide(g3);
          tangentPointG3 = Util.findGearTangentPoints(intersection, g3)[tangentSideG3];
          path = [tangentPointG1, intersection, tangentPointG3];
          replacementGears = this.findSupportingGearsOnPath(acknowledgedGears, g1, path, 0, false);
          if (indexOf.call(replacementGears, g2) >= 0) {
            return false;
          }
          gears.splice.apply(gears, [j, 1].concat(replacementGears));
          this.removeRepeatedGears(gears);
          return this.update(board, gears);
        }
        gear = Util.findNearestIntersectingGear(acknowledgedGears, lineSegment1, Util.makeSet(g1.id, g2.id));
        if (gear != null) {
          gears.splice(j, 0, gear);
          if (this.containsSuccessiveOverlappingGears(gears)) {
            return false;
          }
        }
        i++;
      }
      updatedPoints = [];
      for (i = l = 0, ref = numberOfGears; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        j = (i + 1) % numberOfGears;
        g1 = gears[i];
        g2 = gears[j];
        tangentLine = Util.findTangentLine(g1, g2, this.innerGearIds, this.direction);
        updatedPoints.push(tangentLine.start, tangentLine.end);
      }
      updatedSegments = [];
      for (i = m = 0, ref1 = numberOfGears; 0 <= ref1 ? m < ref1 : m > ref1; i = 0 <= ref1 ? ++m : --m) {
        p0 = updatedPoints[2 * i];
        p1 = updatedPoints[2 * i + 1];
        p2 = updatedPoints[2 * ((i + 1) % numberOfGears)];
        gear = gears[(i + 1) % numberOfGears];
        lineSegment = new LineSegment(p0, p1);
        arcStart = Math.atan2(p1.y - gear.location.y, p1.x - gear.location.x);
        arcEnd = Math.atan2(p2.y - gear.location.y, p2.x - gear.location.x);
        direction = (this.direction === Util.Direction.CLOCKWISE) === (gear.id in this.innerGearIds) ? Util.Direction.CLOCKWISE : Util.Direction.COUNTER_CLOCKWISE;
        arcSegment = new ArcSegment(gear.location, gear.pitchRadius, arcStart, arcEnd, direction);
        updatedSegments.push(lineSegment, arcSegment);
      }
      numberOfSegments = updatedSegments.length;
      for (i = n = 0, ref2 = numberOfSegments - 2; 0 <= ref2 ? n < ref2 : n > ref2; i = 0 <= ref2 ? ++n : --n) {
        for (j = o = ref3 = i + 2, ref4 = numberOfSegments; ref3 <= ref4 ? o < ref4 : o > ref4; j = ref3 <= ref4 ? ++o : --o) {
          if (i !== 0 || j !== numberOfSegments - 1) {
            s1 = updatedSegments[i];
            s2 = updatedSegments[j];
            if (s1.distanceToSegment(s2) < Chain.WIDTH) {
              if ((i + 2) === j) {
                middleSegment = updatedSegments[i + 1];
                if ((middleSegment instanceof ArcSegment) && (middleSegment.getLength() < 2 * Chain.WIDTH)) {
                  continue;
                }
              }
              if (((j + 2) % numberOfSegments) === i) {
                middleSegment = updatedSegments[(j + 1) % numberOfSegments];
                if ((middleSegment instanceof ArcSegment) && (middleSegment.getLength() < 2 * Chain.WIDTH)) {
                  continue;
                }
              }
              return false;
            }
          }
        }
      }
      updatedIgnoredGearIds = this.findIgnoredGearIdsInTightenedChain(board);
      updatedAcknowledgedGears = board.getAcknowledgedGears(updatedIgnoredGearIds);
      chainPolygon = this.toPolygon(updatedSegments);
      updatedInnerGearIds = {};
      for (id in updatedAcknowledgedGears) {
        if (!hasProp.call(updatedAcknowledgedGears, id)) continue;
        gear = updatedAcknowledgedGears[id];
        if (Util.isPointInsidePolygon(gear.location, chainPolygon)) {
          updatedInnerGearIds[id] = true;
        }
      }
      ref5 = this.innerGearIds;
      for (gearId in ref5) {
        if (!hasProp.call(ref5, gearId)) continue;
        if (!(gearId in updatedInnerGearIds) && (indexOf.call(this.supportingGearIds, gearId) >= 0)) {
          return false;
        }
      }
      this.points = updatedPoints;
      this.segments = updatedSegments;
      this.ignoredGearIds = updatedIgnoredGearIds;
      this.innerGearIds = updatedInnerGearIds;
      this.supportingGearIds = (function() {
        var len, q, results;
        results = [];
        for (q = 0, len = gears.length; q < len; q++) {
          gear = gears[q];
          results.push(gear.id);
        }
        return results;
      })();
      return true;
    };

    Chain.prototype.tighten = function(board) {
      var acknowledgedGears, gear;
      this.ignoredGearIds = this.findIgnoredGearIds(board);
      acknowledgedGears = board.getAcknowledgedGears(this.ignoredGearIds);
      this.innerGearIds = Util.makeSetFromList((function() {
        var l, len, ref, results;
        ref = Util.findGearsInsidePolygon(this.points, acknowledgedGears);
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          gear = ref[l];
          results.push(gear.id);
        }
        return results;
      }).call(this));
      if (Object.keys(this.innerGearIds).length < 2) {
        return false;
      }
      this.direction = Util.findDirection(this.points);
      this.supportingGearIds = this.findSupportingGearIds(acknowledgedGears);
      return this.update(board);
    };

    Chain.prototype.clone = function() {
      var copy;
      copy = new Chain(this.points, this.id, this.group, this.level, Util.clone(this.connections));
      copy.segments = Util.clone(this.segments);
      copy.ignoredGearIds = Util.clone(this.ignoredGearIds);
      copy.innerGearIds = Util.clone(this.innerGearIds);
      copy.direction = this.direction;
      copy.supportingGearIds = Util.clone(this.supportingGearIds);
      return copy;
    };

    Chain.fromObject = function(obj) {
      var chain, createSegment, p, points, segment;
      createSegment = function(obj) {
        if (obj.center != null) {
          return ArcSegment.fromObject(obj);
        } else {
          return LineSegment.fromObject(obj);
        }
      };
      points = (function() {
        var l, len, ref, results;
        ref = obj.points;
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          p = ref[l];
          results.push(new Point(p.x, p.y));
        }
        return results;
      })();
      chain = new Chain(points, obj.id, obj.group, obj.level, obj.connections);
      chain.segments = (function() {
        var l, len, ref, results;
        ref = obj.segments;
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          segment = ref[l];
          results.push(createSegment(segment));
        }
        return results;
      })();
      chain.ignoredGearIds = obj.ignoredGearIds;
      chain.innerGearIds = obj.innerGearIds;
      chain.direction = obj.direction;
      chain.supportingGearIds = obj.supportingGearIds;
      return chain;
    };

    return Chain;

  })();

  window.gearsketch.model.Chain = Chain;

  Board = (function() {
    var AXIS_RADIUS, ConnectionType, EPSILON, MIN_STACKED_GEARS_TEETH_DIFFERENCE, MODULE, SNAPPING_DISTANCE;

    MODULE = Util.MODULE;

    AXIS_RADIUS = Util.AXIS_RADIUS;

    MIN_STACKED_GEARS_TEETH_DIFFERENCE = Util.MIN_STACKED_GEARS_TEETH_DIFFERENCE;

    SNAPPING_DISTANCE = Util.SNAPPING_DISTANCE;

    EPSILON = Util.EPSILON;

    ConnectionType = {
      ANY: "any",
      MESHING: "meshing",
      AXIS: "axis",
      CHAIN_INSIDE: "chain_inside",
      CHAIN_OUTSIDE: "chain_outside"
    };

    function Board(gears1, chains, inputGear, outputGear) {
      this.gears = gears1 != null ? gears1 : {};
      this.chains = chains != null ? chains : {};
      this.inputGear = inputGear != null ? inputGear : null;
      this.outputGear = outputGear != null ? outputGear : null;
    }

    Board.prototype.restore = function(board) {
      var gear, id, ref;
      ref = this.gears;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        gear = ref[id];
        gear.restore(board.gears[id]);
      }
      return this.chains = board.chains;
    };

    Board.prototype.restoreAfterDemo = function(board) {
      this.gears = board.gears;
      return this.chains = board.chains;
    };

    Board.prototype.clear = function() {
      this.gears = {};
      return this.chains = {};
    };

    Board.prototype.getNextGroup = function() {
      var gear, id, nextGroup, ref;
      nextGroup = 0;
      ref = this.gears;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        gear = ref[id];
        nextGroup = Math.max(nextGroup, gear.group + 1);
      }
      return nextGroup;
    };

    Board.prototype.getInputGear = function() {
      return this.gears[this.inputGear];
    };

    Board.prototype.getOutputGear = function() {
      return this.gears[this.outputGear];
    };

    Board.prototype.setInputGear = function(gear) {
      return this.inputGear = gear != null ? gear.id : void 0;
    };

    Board.prototype.setOutputGear = function(gear) {
      return this.outputGear = gear != null ? gear.id : void 0;
    };

    Board.prototype.getGears = function() {
      return this.gears;
    };

    Board.prototype.getGearList = function() {
      var gear, id, ref, results;
      ref = this.gears;
      results = [];
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        gear = ref[id];
        results.push(gear);
      }
      return results;
    };

    Board.prototype.getAcknowledgedGears = function(ignoredGearIds) {
      var acknowledgedGears, gear, id, ref;
      acknowledgedGears = {};
      ref = this.gears;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        gear = ref[id];
        if (!(id in ignoredGearIds)) {
          acknowledgedGears[id] = gear;
        }
      }
      return acknowledgedGears;
    };

    Board.prototype.getLevelScore = function(gear) {
      return 1000 * gear.group + gear.level;
    };

    Board.prototype.getGearsSortedByGroupAndLevel = function(gears) {
      if (gears == null) {
        gears = this.getGearList();
      }
      return gears.sort((function(_this) {
        return function(g1, g2) {
          return _this.getLevelScore(g1) - _this.getLevelScore(g2);
        };
      })(this));
    };

    Board.prototype.removeConnection = function(turningObject1, turningObject2) {
      delete turningObject1.connections[turningObject2.id];
      return delete turningObject2.connections[turningObject1.id];
    };

    Board.prototype.removeAllConnections = function(turningObject) {
      var neighbor, neighborId, ref;
      ref = turningObject.connections;
      for (neighborId in ref) {
        if (!hasProp.call(ref, neighborId)) continue;
        neighbor = this.getTurningObjects()[neighborId];
        this.removeConnection(turningObject, neighbor);
      }
      return this.updateGroupsAndLevels();
    };

    Board.prototype.findNearestAxis = function(gear) {
      var candidate, distance, id, nearestAxis, ref, shortestDistance;
      nearestAxis = null;
      shortestDistance = Number.MAX_VALUE;
      ref = this.gears;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        candidate = ref[id];
        if (candidate !== gear) {
          distance = gear.location.distance(candidate.location);
          if (!nearestAxis || distance < (shortestDistance - EPSILON) || (distance < (shortestDistance + EPSILON) && candidate.numberOfTeeth < nearestAxis.numberOfTeeth)) {
            nearestAxis = candidate;
            shortestDistance = distance;
          }
        }
      }
      return nearestAxis;
    };

    Board.prototype.updateGroupsAndLevelsFrom = function(turningObjectId, group, level, updatedGroups, updatedLevels) {
      var connectionType, connections, gear, neighbor, neighborId, results, sameLevelConnectionTypes, turningObject;
      turningObject = this.getTurningObjects()[turningObjectId];
      updatedGroups[turningObjectId] = group;
      updatedLevels[turningObjectId] = level;
      connections = turningObject.connections;
      sameLevelConnectionTypes = [ConnectionType.MESHING, ConnectionType.CHAIN_INSIDE, ConnectionType.CHAIN_OUTSIDE];
      results = [];
      for (neighborId in connections) {
        if (!hasProp.call(connections, neighborId)) continue;
        connectionType = connections[neighborId];
        if (!(neighborId in updatedGroups)) {
          if (indexOf.call(sameLevelConnectionTypes, connectionType) >= 0) {
            results.push(this.updateGroupsAndLevelsFrom(neighborId, group, level, updatedGroups, updatedLevels));
          } else {
            gear = this.gears[turningObjectId];
            neighbor = this.gears[neighborId];
            if (gear.numberOfTeeth > neighbor.numberOfTeeth) {
              results.push(this.updateGroupsAndLevelsFrom(neighborId, group, level + 1, updatedGroups, updatedLevels));
            } else {
              results.push(this.updateGroupsAndLevelsFrom(neighborId, group, level - 1, updatedGroups, updatedLevels));
            }
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Board.prototype.updateGroupsAndLevels = function() {
      var group, id, ref, ref1, turningObject, updatedGroups, updatedLevels;
      updatedGroups = {};
      updatedLevels = {};
      group = 0;
      ref = this.gears;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        if (!(id in updatedGroups)) {
          this.updateGroupsAndLevelsFrom(id, group, 0, updatedGroups, updatedLevels);
          group++;
        }
      }
      ref1 = this.getTurningObjects();
      for (id in ref1) {
        if (!hasProp.call(ref1, id)) continue;
        turningObject = ref1[id];
        turningObject.group = updatedGroups[id];
        turningObject.level = updatedLevels[id];
      }
      return null;
    };

    Board.prototype.addConnection = function(turningObject1, turningObject2, connectionType) {
      turningObject1.connections[turningObject2.id] = connectionType;
      turningObject2.connections[turningObject1.id] = connectionType;
      return this.updateGroupsAndLevels();
    };

    Board.prototype.findMeshingNeighbors = function(gear) {
      var candidate, candidateId, meshingNeighbors, ref;
      meshingNeighbors = [];
      ref = this.gears;
      for (candidateId in ref) {
        if (!hasProp.call(ref, candidateId)) continue;
        candidate = ref[candidateId];
        if (candidate !== gear && gear.edgeDistance(candidate) < EPSILON) {
          if ((candidate.group !== gear.group) || (candidate.level === gear.level)) {
            meshingNeighbors.push(candidate);
          }
        }
      }
      return meshingNeighbors;
    };

    Board.prototype.findRelativeAlignment = function(gear1, gear2) {
      var angle1, angle2, p1, p2, phase1, phase2, phaseSum, r1, r2, shift1, shift2, toothAngle1, toothAngle2;
      p1 = gear1.location;
      r1 = gear1.rotation;
      p2 = gear2.location;
      r2 = gear2.rotation;
      angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
      angle2 = angle1 + Math.PI;
      shift1 = Util.mod(angle1 - r1, 2 * Math.PI);
      shift2 = Util.mod(angle2 - r2, 2 * Math.PI);
      toothAngle1 = (2 * Math.PI) / gear1.numberOfTeeth;
      toothAngle2 = (2 * Math.PI) / gear2.numberOfTeeth;
      phase1 = (shift1 % toothAngle1) / toothAngle1;
      phase2 = (shift2 % toothAngle2) / toothAngle2;
      phaseSum = (phase1 + phase2) % 1;
      return (phaseSum - 0.25) * toothAngle1;
    };

    Board.prototype.alignGearTeeth = function(rotatingGear, meshingGear) {
      return rotatingGear.rotation += this.findRelativeAlignment(rotatingGear, meshingGear);
    };

    Board.prototype.areMeshingGearsAligned = function(gear1, gear2) {
      return Math.abs(this.findRelativeAlignment(gear1, gear2)) < EPSILON;
    };

    Board.prototype.rotateTurningObjectsFrom = function(turningObject, angle, rotatedTurningObjectIds) {
      var connectionType, neighbor, neighborId, ratio, ref, results;
      if (!(turningObject.id in rotatedTurningObjectIds)) {
        turningObject.rotation = Util.mod(turningObject.rotation + angle, 2 * Math.PI);
        rotatedTurningObjectIds[turningObject.id] = true;
      }
      ref = turningObject.connections;
      results = [];
      for (neighborId in ref) {
        if (!hasProp.call(ref, neighborId)) continue;
        connectionType = ref[neighborId];
        neighbor = this.getTurningObjects()[neighborId];
        if (!(neighborId in rotatedTurningObjectIds)) {
          ratio = this.calculateRatio(turningObject, neighbor, connectionType);
          results.push(this.rotateTurningObjectsFrom(neighbor, angle * ratio, rotatedTurningObjectIds));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Board.prototype.calculateRPM = function() {
      var gear, id, ref, ref1, results;
      ref = this.gears;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        gear = ref[id];
        gear.rpm = 0;
      }
      ref1 = this.gears;
      results = [];
      for (id in ref1) {
        if (!hasProp.call(ref1, id)) continue;
        gear = ref1[id];
        if (gear.momentum) {
          results.push(this.calculateRPMrec(gear, gear.momentum, {}));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Board.prototype.calculateRPMrec = function(turningObject, momentum, rotatedTurningObjectIds) {
      var connectionType, neighbor, neighborId, ratio, ref, results;
      if (!(turningObject.id in rotatedTurningObjectIds)) {
        turningObject.rpm += this.momentumToRPM(momentum);
        rotatedTurningObjectIds[turningObject.id] = true;
      }
      ref = turningObject.connections;
      results = [];
      for (neighborId in ref) {
        if (!hasProp.call(ref, neighborId)) continue;
        connectionType = ref[neighborId];
        neighbor = this.getTurningObjects()[neighborId];
        if (!(neighborId in rotatedTurningObjectIds)) {
          ratio = this.calculateRatio(turningObject, neighbor, connectionType);
          results.push(this.calculateRPMrec(neighbor, momentum * ratio, rotatedTurningObjectIds));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Board.prototype.momentumToRPM = function(momentum) {
      return momentum * 60 / (2 * Math.PI);
    };

    Board.prototype.getConnectedGearsLength = function() {
      var connectedGears, gears;
      gears = this.getGearList();
      if (gears.length < 2) {
        return gears.length;
      } else {
        connectedGears = {};
        this.getConectedObjects(gears[0], connectedGears);
        return Object.keys(connectedGears).length;
      }
    };

    Board.prototype.getConectedObjects = function(gear, connectedGears) {
      var connectionType, neighbor, neighborId, ref, results;
      if (!(gear.id in connectedGears)) {
        connectedGears[gear.id] = true;
      }
      ref = gear.connections;
      results = [];
      for (neighborId in ref) {
        if (!hasProp.call(ref, neighborId)) continue;
        connectionType = ref[neighborId];
        neighbor = this.getTurningObjects()[neighborId];
        if (!(neighborId in connectedGears)) {
          results.push(this.getConectedObjects(neighbor, connectedGears));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Board.prototype.labelGears = function() {
      var connectionType, current, destinationElement, found, graph, neighbor, neighborId, path, queue, ref, root, rootElement;
      path = [];
      rootElement = this.getInputGear();
      destinationElement = this.getOutputGear();
      if (!((rootElement != null) && (destinationElement != null))) {
        return path;
      }
      graph = this.createGraph();
      queue = [];
      root = graph[rootElement.id];
      root.distance = 0;
      queue.push(root);
      found = false;
      while (queue.length > 0 && !found) {
        current = queue.shift();
        ref = current.element.connections;
        for (neighborId in ref) {
          if (!hasProp.call(ref, neighborId)) continue;
          connectionType = ref[neighborId];
          neighbor = graph[neighborId];
          if (neighbor.distance === Infinity) {
            neighbor.distance = current.distance + 1;
            neighbor.parent = current.element;
            queue.push(neighbor);
            if (neighbor.element.id === destinationElement.id) {
              found = true;
            }
          }
        }
      }
      if (found) {
        this.getPathFromGraph(graph, destinationElement, path);
      }
      return path;
    };

    Board.prototype.createGraph = function(graph) {
      var id, obj, ref;
      if (graph == null) {
        graph = {};
      }
      ref = this.getTurningObjects();
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        obj = ref[id];
        graph[obj.id] = new GraphNode(obj);
      }
      return graph;
    };

    Board.prototype.getPathFromGraph = function(graph, node, array) {
      if (graph[node.id].parent !== null) {
        this.getPathFromGraph(graph, graph[node.id].parent, array);
      }
      return array.push(graph[node.id].element);
    };

    Board.prototype.alignMeshingGears = function(gear) {
      var angle, l, len, neighbor, neighbors, r, results, rotatedGearIds;
      rotatedGearIds = {};
      rotatedGearIds[gear.id] = true;
      neighbors = this.findMeshingNeighbors(gear);
      results = [];
      for (l = 0, len = neighbors.length; l < len; l++) {
        neighbor = neighbors[l];
        this.addConnection(gear, neighbor, ConnectionType.MESHING);
        angle = this.findRelativeAlignment(neighbor, gear);
        r = neighbor.rotation;
        this.alignGearTeeth(neighbor, gear);
        angle = neighbor.rotation - r;
        rotatedGearIds[neighbor.id] = true;
        results.push(this.rotateTurningObjectsFrom(neighbor, angle, rotatedGearIds));
      }
      return results;
    };

    Board.prototype.connectToAxis = function(upperGear, lowerGear) {
      this.addConnection(upperGear, lowerGear, ConnectionType.AXIS);
      upperGear.location = lowerGear.location.clone();
      upperGear.rotation = lowerGear.rotation;
      return this.alignMeshingGears(upperGear);
    };

    Board.prototype.findNearestNeighbor = function(gear, gearIdsToIgnore) {
      var edgeDistance, nearestNeighbor, neighbor, neighborId, ref, shortestEdgeDistance;
      if (gearIdsToIgnore == null) {
        gearIdsToIgnore = {};
      }
      nearestNeighbor = null;
      shortestEdgeDistance = Number.MAX_VALUE;
      ref = this.gears;
      for (neighborId in ref) {
        if (!hasProp.call(ref, neighborId)) continue;
        neighbor = ref[neighborId];
        if (neighbor !== gear && !(neighborId in gearIdsToIgnore)) {
          edgeDistance = gear.edgeDistance(neighbor);
          if (edgeDistance < shortestEdgeDistance) {
            nearestNeighbor = neighbor;
            shortestEdgeDistance = edgeDistance;
          }
        }
      }
      return nearestNeighbor;
    };

    Board.prototype.connectToOneMeshingGear = function(gear, meshingGear) {
      var angle, delta;
      delta = gear.location.minus(meshingGear.location);
      angle = Math.atan2(delta.y, delta.x);
      gear.location = meshingGear.location.plus(Point.polar(angle, gear.pitchRadius + meshingGear.pitchRadius));
      this.alignGearTeeth(gear, meshingGear);
      return this.addConnection(gear, meshingGear, ConnectionType.MESHING);
    };

    Board.prototype.connectToTwoMeshingGears = function(gear, meshingGear1, meshingGear2) {
      var a, d, h, p0, p1, p2, p3_1, p3_2, p3x1, p3x2, p3y1, p3y2, r0, r1;
      p0 = meshingGear1.location;
      p1 = meshingGear2.location;
      r0 = meshingGear1.pitchRadius + gear.pitchRadius;
      r1 = meshingGear2.pitchRadius + gear.pitchRadius;
      d = p0.distance(p1);
      if (r0 + r1 < d || p0.distance(p1) < EPSILON) {
        if (gear.edgeDistance(meshingGear1) < gear.edgeDistance(meshingGear2)) {
          this.connectToOneMeshingGear(gear, meshingGear1);
          return;
        } else {
          this.connectToOneMeshingGear(gear, meshingGear2);
          return;
        }
      }
      a = (r0 * r0 - r1 * r1 + d * d) / (2 * d);
      h = Math.sqrt(r0 * r0 - a * a);
      p2 = p0.plus(p1.minus(p0).times(a / d));
      p3x1 = p2.x + h * (p1.y - p0.y) / d;
      p3y1 = p2.y - h * (p1.x - p0.x) / d;
      p3x2 = p2.x - h * (p1.y - p0.y) / d;
      p3y2 = p2.y + h * (p1.x - p0.x) / d;
      p3_1 = new Point(p3x1, p3y1);
      p3_2 = new Point(p3x2, p3y2);
      if (gear.location.distance(p3_1) < gear.location.distance(p3_2)) {
        gear.location = p3_1;
      } else {
        gear.location = p3_2;
      }
      return this.alignMeshingGears(gear);
    };

    Board.prototype.doChainsCrossNonSupportingGears = function() {
      var chain, id, ref;
      ref = this.chains;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        chain = ref[id];
        if (chain.crossesNonSupportingGears(this)) {
          return true;
        }
      }
      return false;
    };

    Board.prototype.doChainsCrossEachOther = function(c1, c2) {
      if ((c1.group !== c2.group) || (c1.level === c2.level)) {
        if (c1.distanceToChain(c2) < Chain.WIDTH) {
          return true;
        }
      }
      return false;
    };

    Board.prototype.doesChainCrossAnyOtherChain = function(chain) {
      var chain2, id2, ref;
      ref = this.chains;
      for (id2 in ref) {
        if (!hasProp.call(ref, id2)) continue;
        chain2 = ref[id2];
        if (chain !== chain2) {
          if (this.doChainsCrossEachOther(chain, chain2)) {
            return true;
          }
        }
      }
      return false;
    };

    Board.prototype.doAnyChainsCrossEachOther = function() {
      var c1, c2, chain, chainList, i, id, j, l, m, numberOfChains, ref, ref1, ref2;
      chainList = (function() {
        var ref, results;
        ref = this.chains;
        results = [];
        for (id in ref) {
          if (!hasProp.call(ref, id)) continue;
          chain = ref[id];
          results.push(chain);
        }
        return results;
      }).call(this);
      numberOfChains = chainList.length;
      if (numberOfChains < 2) {
        return false;
      }
      for (i = l = 0, ref = numberOfChains - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        for (j = m = ref1 = i + 1, ref2 = numberOfChains; ref1 <= ref2 ? m < ref2 : m > ref2; j = ref1 <= ref2 ? ++m : --m) {
          c1 = chainList[i];
          c2 = chainList[j];
          if (this.doChainsCrossEachOther(c1, c2)) {
            return true;
          }
        }
      }
      return false;
    };

    Board.prototype.areAllMeshingGearsAligned = function() {
      var g1, g2, gears, i, j, l, m, numberOfGears, ref, ref1, ref2;
      gears = this.getGearList();
      numberOfGears = gears.length;
      if (numberOfGears < 2) {
        return true;
      }
      for (i = l = 0, ref = numberOfGears - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        for (j = m = ref1 = i + 1, ref2 = numberOfGears; ref1 <= ref2 ? m < ref2 : m > ref2; j = ref1 <= ref2 ? ++m : --m) {
          g1 = gears[i];
          g2 = gears[j];
          if (g1.connections[g2.id] === ConnectionType.MESHING) {
            if (!this.areMeshingGearsAligned(g1, g2)) {
              return false;
            }
          }
        }
      }
      return true;
    };

    Board.prototype.calculateRatio = function(turningObject1, turningObject2, connectionType) {
      if (connectionType === ConnectionType.AXIS) {
        return 1;
      } else if ((connectionType === ConnectionType.MESHING) || (connectionType === ConnectionType.CHAIN_OUTSIDE)) {
        return -turningObject1.getCircumference() / turningObject2.getCircumference();
      } else {
        return turningObject1.getCircumference() / turningObject2.getCircumference();
      }
    };

    Board.prototype.calculatePathRatio = function(path) {
      var connectionType, i, l, pathLength, ratio, ref, turningObject1, turningObject2;
      ratio = 1;
      pathLength = path.length;
      for (i = l = 0, ref = pathLength - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        turningObject1 = path[i];
        turningObject2 = path[i + 1];
        connectionType = turningObject1.connections[turningObject2.id];
        ratio *= this.calculateRatio(turningObject1, turningObject2, connectionType);
      }
      return ratio;
    };

    Board.prototype.areConnectionRatiosConsistent = function() {
      var l, len, path, pathName, paths, ratio, ratios;
      ratios = {};
      paths = Util.findAllSimplePathsBetweenNeighbors(this.getTurningObjects());
      for (l = 0, len = paths.length; l < len; l++) {
        path = paths[l];
        pathName = path[0].id + "-" + path[path.length - 1].id;
        ratio = this.calculatePathRatio(path);
        if (ratios[pathName] == null) {
          ratios[pathName] = ratio;
        } else {
          if (Math.abs(ratios[pathName] - ratio) > EPSILON) {
            return false;
          }
        }
      }
      return true;
    };

    Board.prototype.isBoardValid = function() {
      var axisDistance, combinedOuterRadius, gear1, gear2, group1, group2, id1, id2, level1, level2, maxOuterRadius, ref, ref1;
      ref = this.gears;
      for (id1 in ref) {
        if (!hasProp.call(ref, id1)) continue;
        gear1 = ref[id1];
        group1 = gear1.group;
        level1 = gear1.level;
        ref1 = this.gears;
        for (id2 in ref1) {
          if (!hasProp.call(ref1, id2)) continue;
          gear2 = ref1[id2];
          if (gear1 !== gear2) {
            group2 = gear2.group;
            level2 = gear2.level;
            axisDistance = gear1.location.distance(gear2.location);
            maxOuterRadius = Math.max(gear1.outerRadius, gear2.outerRadius);
            combinedOuterRadius = gear1.outerRadius + gear2.outerRadius;
            if (axisDistance < EPSILON) {
              if ((group1 !== group2) || (level1 === level2)) {
                return false;
              }
            } else if (group1 === group2 && level1 === level2 && (gear1.connections[gear2.id] == null)) {
              if (axisDistance < combinedOuterRadius) {
                return false;
              }
            } else if (axisDistance < maxOuterRadius + AXIS_RADIUS) {
              return false;
            }
          }
        }
      }
      return !this.doChainsCrossNonSupportingGears() && !this.doAnyChainsCrossEachOther() && this.areAllMeshingGearsAligned() && this.areConnectionRatiosConsistent();
    };

    Board.prototype.placeGear = function(gear, location) {
      var chain, id, nearestAxis, neighbor1, neighbor2, oldBoard, ref;
      oldBoard = this.clone();
      this.removeAllConnections(gear);
      gear.location = location.clone();
      nearestAxis = this.findNearestAxis(gear);
      if (nearestAxis && gear.location.distance(nearestAxis.location) < SNAPPING_DISTANCE && nearestAxis.numberOfTeeth - gear.numberOfTeeth > MIN_STACKED_GEARS_TEETH_DIFFERENCE) {
        this.connectToAxis(gear, nearestAxis);
      } else {
        neighbor1 = this.findNearestNeighbor(gear);
        if (neighbor1 && gear.edgeDistance(neighbor1) < SNAPPING_DISTANCE) {
          neighbor2 = this.findNearestNeighbor(gear, Util.makeSet(neighbor1.id));
          if (neighbor2 && gear.edgeDistance(neighbor2) < SNAPPING_DISTANCE) {
            this.connectToTwoMeshingGears(gear, neighbor1, neighbor2);
          } else {
            this.connectToOneMeshingGear(gear, neighbor1);
          }
        }
      }
      ref = this.chains;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        chain = ref[id];
        if (chain.update(this)) {
          this.updateChainConnections(chain);
        } else {
          this.restore(oldBoard);
          return false;
        }
      }
      if (this.isBoardValid()) {
        return true;
      } else {
        this.restore(oldBoard);
        return false;
      }
    };

    Board.prototype.addGearToChains = function(gear) {
      var chain, id, ref, results;
      ref = this.chains;
      results = [];
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        chain = ref[id];
        if (Util.isPointInsidePolygon(gear.location, chain.toPolygon())) {
          results.push(chain.innerGearIds[gear.id] = true);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Board.prototype.removeGearFromChains = function(gear) {
      var chain, id, ref, results;
      ref = this.chains;
      results = [];
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        chain = ref[id];
        if (!chain.removeGear(gear, this) || this.doesChainCrossAnyOtherChain(chain)) {
          results.push(this.removeChain(chain));
        } else {
          results.push(this.updateChainConnections(chain));
        }
      }
      return results;
    };

    Board.prototype.addGear = function(gear) {
      var oldBoard;
      oldBoard = this.clone();
      gear.group = this.getNextGroup();
      this.gears[gear.id] = gear;
      this.addGearToChains(gear);
      if (!this.placeGear(gear, gear.location)) {
        this.removeGear(gear);
        this.restore(oldBoard);
        return false;
      } else {
        return true;
      }
    };

    Board.prototype.removeGear = function(gear) {
      if (gear.id === this.inputGear) {
        delete this.inputGear;
      }
      if (gear.id === this.outputGear) {
        delete this.outputGear;
      }
      this.removeAllConnections(gear);
      delete this.gears[gear.id];
      return this.removeGearFromChains(gear);
    };

    Board.prototype.getGearAt = function(location, candidates) {
      var candidate, distance, gear, id;
      if (candidates == null) {
        candidates = this.gears;
      }
      gear = null;
      for (id in candidates) {
        if (!hasProp.call(candidates, id)) continue;
        candidate = candidates[id];
        distance = location.distance(candidate.location);
        if (distance < candidate.outerRadius) {
          if (!gear || candidate.numberOfTeeth < gear.numberOfTeeth) {
            gear = candidate;
          }
        }
      }
      return gear;
    };

    Board.prototype.isTopLevelGear = function(gear) {
      var connectionType, id, ref;
      ref = gear.connections;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        connectionType = ref[id];
        if (connectionType === ConnectionType.AXIS && this.gears[id].level > gear.level) {
          return false;
        }
      }
      return true;
    };

    Board.prototype.getTopLevelGears = function() {
      var gear, id, ref, topLevelGears;
      topLevelGears = {};
      ref = this.gears;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        gear = ref[id];
        if (this.isTopLevelGear(gear)) {
          topLevelGears[id] = gear;
        }
      }
      return topLevelGears;
    };

    Board.prototype.getTopLevelGearAt = function(location) {
      return this.getGearAt(location, this.getTopLevelGears());
    };

    Board.prototype.getGearWithId = function(id) {
      return this.gears[id];
    };

    Board.prototype.getGearsWithIds = function(ids) {
      var id, l, len, results;
      results = [];
      for (l = 0, len = ids.length; l < len; l++) {
        id = ids[l];
        results.push(this.gears[id]);
      }
      return results;
    };

    Board.prototype.rotateAllTurningObjects = function(delta) {
      var angle, gear, id, ref, results;
      ref = this.gears;
      results = [];
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        gear = ref[id];
        if (gear.momentum) {
          angle = gear.momentum * (delta / 1000);
          results.push(this.rotateTurningObjectsFrom(gear, angle, {}));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Board.prototype.addChainConnections = function(chain) {
      var gearId, l, len, ref, results;
      ref = chain.supportingGearIds;
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        gearId = ref[l];
        if (gearId in chain.innerGearIds) {
          results.push(this.addConnection(chain, this.getGearWithId(gearId), ConnectionType.CHAIN_INSIDE));
        } else {
          results.push(this.addConnection(chain, this.getGearWithId(gearId), ConnectionType.CHAIN_OUTSIDE));
        }
      }
      return results;
    };

    Board.prototype.updateChainConnections = function(chain) {
      this.removeAllConnections(chain);
      return this.addChainConnections(chain);
    };

    Board.prototype.addChain = function(chain) {
      var oldBoard;
      oldBoard = this.clone();
      this.chains[chain.id] = chain;
      if (chain.tighten(this)) {
        this.chains[chain.id] = chain;
        this.addChainConnections(chain);
      } else {
        this.restore(oldBoard);
        return false;
      }
      if (this.isBoardValid()) {
        return true;
      } else {
        this.restore(oldBoard);
        return false;
      }
    };

    Board.prototype.removeChain = function(chain) {
      this.removeAllConnections(chain);
      return delete this.chains[chain.id];
    };

    Board.prototype.getChains = function() {
      return this.chains;
    };

    Board.prototype.getChainsInGroupOnLevel = function(group, level) {
      var chain, id, ref, results;
      ref = this.chains;
      results = [];
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        chain = ref[id];
        if ((chain.group === group) && (chain.level === level)) {
          results.push(chain);
        }
      }
      return results;
    };

    Board.prototype.getTurningObjects = function() {
      var chain, gear, id, ref, ref1, turningObjects;
      turningObjects = {};
      ref = this.gears;
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        gear = ref[id];
        turningObjects[id] = gear;
      }
      ref1 = this.chains;
      for (id in ref1) {
        if (!hasProp.call(ref1, id)) continue;
        chain = ref1[id];
        turningObjects[id] = chain;
      }
      return turningObjects;
    };

    Board.prototype.clone = function() {
      return {
        gears: Util.clone(this.gears),
        chains: Util.clone(this.chains)
      };
    };

    Board.fromObject = function(obj) {
      var board, chain, gear, id, ref, ref1;
      board = new Board();
      ref = obj.gears;
      for (id in ref) {
        gear = ref[id];
        board.gears[id] = Gear.fromObject(gear);
      }
      ref1 = obj.chains;
      for (id in ref1) {
        chain = ref1[id];
        board.chains[id] = Chain.fromObject(chain);
      }
      board.inputGear = obj.inputGear;
      board.outputGear = obj.outputGear;
      return board;
    };

    return Board;

  })();

  window.gearsketch.model.Board = Board;

  Game = (function() {
    function Game(board1, title, rules, inputs, modals, level3) {
      this.board = board1;
      this.title = title != null ? title : "";
      this.rules = rules != null ? rules : {};
      this.inputs = inputs != null ? inputs : {};
      this.modals = modals != null ? modals : {};
      this.level = level3 != null ? level3 : 0;
      if (this.board == null) {
        this.board = new Board();
      }
    }

    Game.prototype.validate = function() {
      var id, input, ref, ref1, rule;
      this.checksPassed = true;
      this.labeledGears = this.board.labelGears();
      ref = this.rules;
      for (id in ref) {
        rule = ref[id];
        this.validateRule(rule);
      }
      ref1 = this.inputs;
      for (id in ref1) {
        input = ref1[id];
        this.validateInput(input);
      }
      console.log(this.checksPassed ? "Todas las Validaciones pasaron" : "Oh snap! hubo algun error!");
      console.log("end of validation");
      return this.checksPassed;
    };

    Game.prototype.validateRule = function(rule) {
      return this.checksPassed = this.checksPassed && rule.check(this.board, this.labeledGears);
    };

    Game.prototype.validateInput = function(input) {
      return this.checksPassed = this.checksPassed && input.check();
    };

    Game.fromObject = function(obj) {
      var game, id, input, ref, ref1, rule;
      game = new Game();
      if ((obj.title != null)) {
        game.title = obj.title;
      }
      game.modals = obj.modals;
      game.level = obj.level;
      if (obj.board) {
        game.board = Board.fromObject(obj.board);
      }
      ref = obj.rules;
      for (id in ref) {
        rule = ref[id];
        game.rules[id] = Rule.fromObject(rule);
      }
      ref1 = obj.inputs;
      for (id in ref1) {
        input = ref1[id];
        game.inputs[id] = ValidationInput.fromObject(input);
      }
      return game;
    };

    return Game;

  })();

  window.gearsketch.model.Game = Game;

  Rule = (function() {
    var RuleType, TargetType;

    RuleType = {
      NUMBER_OF_GEARS: "number_of_gears",
      CHECK_CONTINUITY: "check_continuity",
      CHECK_CHAIN_EXISTENCE: "check_chain_existence",
      CHECK_PROPERTY_EQUALS: "check_property_equals",
      CHECK_PROPERTY_NOT_EQUALS: "check_property_not_equals",
      CHECK_PROPERTY_LESS_THAN: "check_property_less_than",
      CHECK_PROPERTY_GREATER_THAN: "check_property_greater_than"
    };

    TargetType = {
      FIRST: "none",
      INPUT_GEAR: "input_gear",
      OUTPUT_GEAR: "output_gear"
    };

    function Rule(id3, ruleType, properties) {
      this.id = id3;
      this.ruleType = ruleType;
      this.properties = properties;
      if (this.id == null) {
        this.id = Util.createUUID();
      }
    }

    Rule.prototype.check = function(board, labeledGears) {
      var ref;
      switch (this.ruleType) {
        case RuleType.NUMBER_OF_GEARS:
          return ((ref = this.properties) != null ? ref.value : void 0) === board.getGearList().length;
        case RuleType.CHECK_CONTINUITY:
          return this.continuityCheck(board);
        case RuleType.CHECK_CHAIN_EXISTENCE:
          return this.chainCheck(board);
        default:
          return this.propertyCheck(board, labeledGears);
      }
    };

    Rule.prototype.propertyCheck = function(board, labeledGears) {
      var actualValue, ref, ref1, ref2, ref3, ref4, ref5, ref6, target;
      target = (function() {
        var ref, ref1, ref2;
        switch ((ref = this.properties) != null ? ref.target : void 0) {
          case TargetType.FIRST:
            return (ref1 = board.getGearList()) != null ? ref1[0] : void 0;
          case TargetType.INPUT_GEAR:
            return board.getInputGear();
          case TargetType.OUTPUT_GEAR:
            return board.getOutputGear();
          default:
            return labeledGears[(ref2 = this.properties) != null ? ref2.target : void 0];
        }
      }).call(this);
      actualValue = ((ref = this.properties) != null ? ref.useAbsoluteMagnitud : void 0) != null ? Math.abs(target != null ? target[(ref1 = this.properties) != null ? ref1.property : void 0] : void 0) : target != null ? target[(ref2 = this.properties) != null ? ref2.property : void 0] : void 0;
      switch (this.ruleType) {
        case RuleType.CHECK_PROPERTY_EQUALS:
          return Math.round(actualValue * 100) / 100 === ((ref3 = this.properties) != null ? ref3.value : void 0);
        case RuleType.CHECK_PROPERTY_NOT_EQUALS:
          return (actualValue != null) && Math.round(actualValue * 100) / 100 !== ((ref4 = this.properties) != null ? ref4.value : void 0);
        case RuleType.CHECK_PROPERTY_LESS_THAN:
          return actualValue < ((ref5 = this.properties) != null ? ref5.value : void 0);
        case RuleType.CHECK_PROPERTY_GREATER_THAN:
          return actualValue > ((ref6 = this.properties) != null ? ref6.value : void 0);
        default:
          return false;
      }
    };

    Rule.prototype.getSign = function(number) {
      if (number < 0) {
        return -1;
      } else {
        return 1;
      }
    };

    Rule.prototype.chainCheck = function(board) {
      var ref;
      return ((ref = this.properties) != null ? ref.value : void 0) === (Object.keys(board.getChains()).length !== 0);
    };

    Rule.prototype.continuityCheck = function(board) {
      return board.getConnectedGearsLength() === board.getGearList().length;
    };

    Rule.prototype.hasNeighbors = function(gear) {
      return Object.keys(gear.connections).length !== 0;
    };

    Rule.fromObject = function(obj) {
      return new Rule(obj.id, obj.ruleType, obj.properties);
    };

    return Rule;

  })();

  window.gearsketch.model.Rule = Rule;

  ValidationInput = (function() {
    var InputType;

    InputType = {
      TEXT: "text",
      RADIO: "radio",
      NUMBER: "number"
    };

    function ValidationInput(id3, inputType, correctValue, actualValue1, properties) {
      this.id = id3;
      this.inputType = inputType;
      this.correctValue = correctValue != null ? correctValue : "";
      this.actualValue = actualValue1 != null ? actualValue1 : "";
      this.properties = properties != null ? properties : {};
      if (this.id == null) {
        this.id = Util.createUUID();
      }
    }

    ValidationInput.prototype.check = function() {
      switch (this.inputType) {
        case InputType.TEXT:
          return this.actualValue === this.correctValue;
        case InputType.NUMBER:
          return Number(this.actualValue) === Number(this.correctValue);
        case InputType.RADIO:
          return this.actualValue === this.correctValue;
      }
    };

    ValidationInput.fromObject = function(obj) {
      return new ValidationInput(obj.id, obj.inputType, obj.correctValue, obj.actualValue, obj.properties);
    };

    return ValidationInput;

  })();

  window.gearsketch.model.ValidationInput = ValidationInput;

  ValidationResult = (function() {
    function ValidationResult(level3, key, time, completed) {
      this.level = level3 != null ? level3 : 0;
      this.key = key != null ? key : "keyasdas";
      this.time = time != null ? time : 33;
      this.completed = completed != null ? completed : false;
    }

    return ValidationResult;

  })();

  window.gearsketch.model.ValidationResult = ValidationResult;

  GraphNode = (function() {
    function GraphNode(element, distance1, parent) {
      this.element = element;
      this.distance = distance1 != null ? distance1 : Infinity;
      this.parent = parent != null ? parent : null;
    }

    return GraphNode;

  })();

  window.gearsketch.model.GraphNode = GraphNode;

}).call(this);

//# sourceMappingURL=gearsketch_model.js.map
