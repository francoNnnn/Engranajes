// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var ArcSegment, Board, Chain, FPS, Game, Gear, GearSketch, LineSegment, MIN_GEAR_TEETH, MIN_MOMENTUM, Point, Util, ValidationResult,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  Point = window.gearsketch.Point;

  ArcSegment = window.gearsketch.ArcSegment;

  LineSegment = window.gearsketch.LineSegment;

  Util = window.gearsketch.Util;

  Gear = window.gearsketch.model.Gear;

  Chain = window.gearsketch.model.Chain;

  Board = window.gearsketch.model.Board;

  Game = window.gearsketch.model.Game;

  ValidationResult = window.gearsketch.model.ValidationResult;

  FPS = 60;

  MIN_GEAR_TEETH = 8;

  MIN_MOMENTUM = 0.2;

  GearSketch = (function() {
    var AXIS_RADIUS, Action, BUTTON_INFO, EXTENDED_BUTTON_INFO, HIDDEN_MENU_BUTTONS, MENU_BUTTONS, MODULE, MovementAction, MovementType;

    MODULE = Util.MODULE;

    AXIS_RADIUS = Util.AXIS_RADIUS;

    BUTTON_INFO = [["backButton", "backButton.png"], ["playButton", "PlayIcon.png"], ["helpButton", "HelpIcon.png"], ["selectInputGear", "GearInput.png"], ["selectOutputGear", "GearOutput.png"], ["showFormulas", "flask.png"]];

    EXTENDED_BUTTON_INFO = [["showObjectives", "info.png"], ["tryVerify", "verify.png"]];

    MovementAction = {
      PEN_DOWN: "penDown",
      PEN_UP: "penUp",
      PEN_TAP: "penTap"
    };

    MovementType = {
      STRAIGHT: "straight",
      CIRCLE: "circle",
      LEFT_HALF_CIRCLE: "leftHalfCircle",
      RIGHT_HALF_CIRCLE: "rightHalfCircle"
    };

    Action = {
      DRAGGING: "dragging",
      SETTING_MOMENTUM: "settingMomentum",
      STROKING: "stroking"
    };

    GearSketch.prototype.buttons = {};

    GearSketch.prototype.loadedButtons = 0;

    GearSketch.prototype.areButtonsLoaded = false;

    GearSketch.prototype.gearImages = {};

    GearSketch.prototype.currentAction = null;

    GearSketch.prototype.isPenDown = false;

    GearSketch.prototype.stroke = [];

    GearSketch.prototype.offset = new Point();

    GearSketch.prototype.isPlaying = false;

    GearSketch.prototype.isDrawingMenu = false;

    GearSketch.prototype.message = "";

    GearSketch.prototype.messageColor = "black";

    GearSketch.prototype.pointerLocation = new Point();

    GearSketch.prototype.currentDemoMovement = 0;

    GearSketch.prototype.movementCompletion = 0;

    GearSketch.prototype.restTimer = 0;

    function GearSketch(showButtons, simpleMenu) {
      if (showButtons == null) {
        showButtons = true;
      }
      this.simpleMenu = simpleMenu != null ? simpleMenu : false;
      this.update = bind(this.update, this);
      this.updateAndDraw = bind(this.updateAndDraw, this);
      this.loadBoard();
      this.loadButtons();
      this.showButtons = showButtons;
      this.loadDemoPointer();
      this.loadGameMenus(this.game);
      this.canvas = document.getElementById("gearsketch_canvas");
      this.canvasOffsetX = this.canvas.getBoundingClientRect().left;
      this.canvasOffsetY = this.canvas.getBoundingClientRect().top;
      this.isDemoPlaying = false;
      this.updateCanvasSize();
      this.addCanvasListeners();
      this.lastUpdateTime = new Date().getTime();
      this.updateAndDraw();
    }

    GearSketch.prototype.buttonLoaded = function() {
      var total;
      total = BUTTON_INFO.length;
      if (!this.simpleMenu) {
        total += EXTENDED_BUTTON_INFO.length;
      }
      this.loadedButtons++;
      if (this.loadedButtons === BUTTON_INFO.length) {
        return this.areButtonsLoaded = true;
      }
    };

    GearSketch.prototype.loadButtons = function() {
      var AllButtons, button, file, j, len, name, ref, results, x, y;
      x = y = 20;
      AllButtons = BUTTON_INFO;
      if (!this.simpleMenu) {
        AllButtons = AllButtons.concat(EXTENDED_BUTTON_INFO);
      }
      results = [];
      for (j = 0, len = AllButtons.length; j < len; j++) {
        ref = AllButtons[j], name = ref[0], file = ref[1];
        button = new Image();
        button.name = name;
        button.onload = (function(_this) {
          return function() {
            return _this.buttonLoaded();
          };
        })(this);
        button.src = "img/" + file;
        button.location = new Point(x, y);
        button.padding = 3;
        this.buttons[name] = button;
        results.push(x += 80);
      }
      return results;
    };

    GearSketch.prototype.loadDemoPointer = function() {
      var image;
      image = new Image();
      image.onload = (function(_this) {
        return function() {
          return _this.pointerImage = image;
        };
      })(this);
      return image.src = "img/hand.png";
    };

    GearSketch.prototype.loadBoard = function() {
      var error, gameJSON, gear, hash, id;
      this.game = (function() {
        var error1;
        if (parent.location.hash.length > 1) {
          try {
            hash = parent.location.hash.substr(1);
            gameJSON = Util.sendGetRequest("boards/" + hash + ".json");
            console.log(JSON.parse(gameJSON));
            return Game.fromObject(JSON.parse(gameJSON));
          } catch (error1) {
            error = error1;
            console.log(error);
            this.displayMessage("Error: could not load game", "red", 2000);
            this.simpleMenu = true;
            return new Game();
          }
        } else {
          this.simpleMenu = true;
          return new Game(new Board());
        }
      }).call(this);
      this.game.key = parent.location.hash.substr(1);
      this.board = this.game.board;
      this.initTime = new Date().getTime();
      if (!(function() {
        var ref, ref1, ref2, results;
        ref = this.board.getGears();
        results = [];
        for (id in ref) {
          gear = ref[id];
          results.push(id === ((ref1 = this.board.getInputGear()) != null ? ref1.id : void 0) || id === ((ref2 = this.board.getOutputGear()) != null ? ref2.id : void 0));
        }
        return results;
      }).call(this)) {
        return this.addGearImage(gear);
      }
    };

    GearSketch.prototype.displayMessage = function(message, color, time) {
      if (color == null) {
        color = "black";
      }
      if (time == null) {
        time = 0;
      }
      this.message = message;
      this.messageColor = color;
      if (time > 0) {
        return setTimeout(((function(_this) {
          return function() {
            return _this.clearMessage();
          };
        })(this)), time);
      }
    };

    GearSketch.prototype.clearMessage = function() {
      return this.message = "";
    };

    GearSketch.prototype.shouldShowButtons = function() {
      return this.showButtons || this.isDemoPlaying;
    };

    GearSketch.prototype.addCanvasListeners = function() {
      var canvasEventHandler;
      canvasEventHandler = Hammer(this.canvas, {
        drag_min_distance: 1
      });
      canvasEventHandler.on("touch", ((function(_this) {
        return function(e) {
          return _this.forwardPenDownEvent.call(_this, e);
        };
      })(this)));
      canvasEventHandler.on("drag", ((function(_this) {
        return function(e) {
          return _this.forwardPenMoveEvent.call(_this, e);
        };
      })(this)));
      return canvasEventHandler.on("release", ((function(_this) {
        return function(e) {
          return _this.forwardPenUpEvent.call(_this, e);
        };
      })(this)));
    };

    GearSketch.prototype.forwardPenDownEvent = function(event) {
      var x, y;
      event.gesture.preventDefault();
      if (this.isDemoPlaying) {
        return this.stopDemo();
      } else {
        x = event.gesture.center.pageX - this.canvasOffsetX;
        y = event.gesture.center.pageY - this.canvasOffsetY;
        return this.handlePenDown(x, y);
      }
    };

    GearSketch.prototype.forwardPenMoveEvent = function(event) {
      var x, y;
      event.gesture.preventDefault();
      if (!this.isDemoPlaying) {
        x = event.gesture.center.pageX - this.canvasOffsetX;
        y = event.gesture.center.pageY - this.canvasOffsetY;
        return this.handlePenMove(x, y);
      }
    };

    GearSketch.prototype.forwardPenUpEvent = function(event) {
      if (!this.isDemoPlaying) {
        return this.handlePenUp();
      }
    };

    GearSketch.prototype.handlePenDown = function(x, y) {
      var button, gear, point, ref, selection;
      point = new Point(x, y);
      if (this.isPenDown) {
        return this.handlePenUp();
      } else {
        this.isPlaying = false;
        button = this.getButtonAt(x, y);
        if (button) {
          if (button.name === "playButton") {
            this.isPlaying = true;
            if (this.board.getGearList().every(function(g) {
              return g.momentum === 0;
            })) {
              return this.displayMessage("Add some arrows!", "black", 2000);
            }
          } else if (button.name === "clearButton") {
            parent.location.hash = "";
            return this.board.clear();
          } else if (button.name === "cloudButton") {
            return this.uploadBoard();
          } else if (button.name === "helpButton") {
            return this.playDemo();
          } else if (button.name === "addTeethButton") {
            return this.addTeeth(this.selectedGear);
          } else if (button.name === "removeTeethButton") {
            return this.removeTeeth(this.selectedGear);
          } else if (button.name === "rpmUpButton") {
            return this.rpmUp(this.selectedGear);
          } else if (button.name === "rpmDownButton") {
            return this.rpmDown(this.selectedGear);
          } else if (button.name === "drawMenuButton") {
            return this.isDrawingMenu = true;
          } else if (button.name === "selectInputGear") {
            return this.selectInputGear();
          } else if (button.name === "selectOutputGear") {
            return this.selectOutputGear();
          } else if (button.name === "showObjectives") {
            return this.showObjectivesModal();
          } else if (button.name === "tryVerify") {
            return this.showSubmitAnswerModal();
          } else if (button.name === "showFormulas") {
            return this.showFormulasModal();
          } else if (button.name === "backButton") {
            return this.showBackConfirmationModal();
          }
        } else {
          this.removeMenu();
          this.isDrawingMenu = false;
          ref = this.gearAt(x, y), gear = ref.gear, selection = ref.selection;
          if (gear) {
            this.selectedGear = gear;
            if (selection === "center") {
              this.currentAction = Action.DRAGGING;
              this.offset = point.minus(this.selectedGear.location);
            } else {
              this.currentAction = Action.SETTING_MOMENTUM;
              this.selectedGear.momentum = 0;
              this.selectedGearMomentum = this.calculateMomentumFromCoords(this.selectedGear, x, y);
            }
          } else {
            this.currentAction = Action.STROKING;
            this.stroke.push(point);
          }
          return this.isPenDown = true;
        }
      }
    };

    GearSketch.prototype.handlePenMove = function(x, y) {
      var canPlaceGear, goalLocation, point;
      point = new Point(x, y);
      if (this.isPenDown) {
        if (this.currentAction === Action.DRAGGING) {
          goalLocation = point.minus(this.offset);
          canPlaceGear = this.board.placeGear(this.selectedGear, goalLocation);
          if (canPlaceGear) {
            return this.goalLocationGear = null;
          } else {
            return this.goalLocationGear = new Gear(goalLocation, this.selectedGear.rotation, this.selectedGear.numberOfTeeth, this.selectedGear.id);
          }
        } else if (this.currentAction === Action.SETTING_MOMENTUM) {
          return this.selectedGearMomentum = this.calculateMomentumFromCoords(this.selectedGear, x, y);
        } else if (this.currentAction === Action.STROKING) {
          return this.stroke.push(point);
        }
      }
    };

    GearSketch.prototype.handlePenUp = function() {
      this.board.calculateRPM();
      if (this.isPenDown) {
        if (this.currentAction === Action.SETTING_MOMENTUM) {
          if (Math.abs(this.selectedGearMomentum) > MIN_MOMENTUM) {
            this.selectedGear.momentum = this.rpmToMomentum(Math.round(this.momentumToRPM(this.selectedGearMomentum)));
          } else {
            this.selectedGear.momentum = 0;
          }
          this.selectedGearMomentum = 0;
        } else if (this.currentAction === Action.STROKING) {
          this.processStroke();
        }
        this.goalLocationGear = null;
        this.isPenDown = false;
        return this.currentAction = null;
      }
    };

    GearSketch.prototype.isButtonAt = function(x, y, button) {
      return x > button.location.x && x < button.location.x + button.width + 2 * button.padding && y > button.location.y && y < button.location.y + button.height + 2 * button.padding;
    };

    GearSketch.prototype.getButtonAt = function(x, y) {
      var button, buttonName, ref;
      if (!this.shouldShowButtons()) {
        return null;
      }
      ref = this.buttons;
      for (buttonName in ref) {
        if (!hasProp.call(ref, buttonName)) continue;
        button = ref[buttonName];
        if (this.isButtonAt(x, y, button)) {
          return button;
        }
      }
      return null;
    };

    GearSketch.prototype.gearAt = function(x, y) {
      var gear, point;
      point = new Point(x, y);
      gear = this.board.getGearAt(point);
      if (!gear) {
        return {
          gear: null
        };
      } else if (gear.location.distance(point) < 0.5 * gear.outerRadius) {
        return {
          gear: gear,
          selection: "center"
        };
      } else {
        return {
          gear: gear,
          selection: "edge"
        };
      }
    };

    GearSketch.prototype.normalizeStroke = function(stroke) {
      var MIN_POINT_DISTANCE, j, len, normalizedStroke, p1, p2, strokeTail;
      MIN_POINT_DISTANCE = 10;
      normalizedStroke = [];
      if (stroke.length > 0) {
        p1 = stroke[0], strokeTail = 2 <= stroke.length ? slice.call(stroke, 1) : [];
        normalizedStroke.push(p1);
        for (j = 0, len = strokeTail.length; j < len; j++) {
          p2 = strokeTail[j];
          if (p1.distance(p2) > MIN_POINT_DISTANCE) {
            normalizedStroke.push(p2);
            p1 = p2;
          }
        }
      }
      return normalizedStroke;
    };

    GearSketch.prototype.createGearFromStroke = function(stroke) {
      var area, doubleArea, height, i, idealTrueAreaRatio, j, k, len, len1, maxX, maxY, minX, minY, numberOfPoints, p, p1, p2, radius, sumX, sumY, t, width, x, y;
      numberOfPoints = stroke.length;
      if (numberOfPoints > 0) {
        sumX = 0;
        sumY = 0;
        minX = Number.MAX_VALUE;
        maxX = Number.MIN_VALUE;
        minY = Number.MAX_VALUE;
        maxY = Number.MIN_VALUE;
        for (j = 0, len = stroke.length; j < len; j++) {
          p = stroke[j];
          sumX += p.x;
          sumY += p.y;
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        }
        width = maxX - minX;
        height = maxY - minY;
        t = Math.floor(0.5 * (width + height) / MODULE);
        doubleArea = 0;
        for (i = k = 0, len1 = stroke.length; k < len1; i = ++k) {
          p1 = stroke[i];
          p2 = stroke[(i + 1) % numberOfPoints];
          doubleArea += p1.cross(p2);
        }
        area = Math.abs(doubleArea) / 2;
        radius = 0.25 * ((maxX - minX) + (maxY - minY));
        idealTrueAreaRatio = (Math.PI * Math.pow(radius, 2)) / area;
        if (idealTrueAreaRatio > 0.80 && idealTrueAreaRatio < 1.20 && t > MIN_GEAR_TEETH) {
          x = sumX / numberOfPoints;
          y = sumY / numberOfPoints;
          return new Gear(new Point(x, y), 0, t);
        }
      }
      return null;
    };

    GearSketch.prototype.removeStrokedGears = function(stroke) {
      var gear, id, ref, results;
      this.selectedGear = null;
      ref = this.board.getTopLevelGears();
      results = [];
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        gear = ref[id];
        if (Util.pointPathDistance(gear.location, stroke, false) < gear.innerRadius) {
          results.push(this.board.removeGear(gear));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    GearSketch.prototype.gearImageLoaded = function(numberOfTeeth, image) {
      return this.gearImages[numberOfTeeth] = image;
    };

    GearSketch.prototype.addGearImage = function(gear) {
      var ctx, gearCanvas, gearCopy, image, size;
      gearCanvas = document.createElement("canvas");
      size = 2 * (gear.outerRadius + MODULE);
      gearCanvas.height = size;
      gearCanvas.width = size;
      ctx = gearCanvas.getContext("2d");
      gearCopy = new Gear(new Point(0.5 * size, 0.5 * size), 0, gear.numberOfTeeth, gear.id);
      this.drawGear(ctx, gearCopy);
      image = new Image();
      image.onload = (function(_this) {
        return function() {
          return _this.gearImageLoaded(gear.numberOfTeeth, image);
        };
      })(this);
      return image.src = gearCanvas.toDataURL("image/png");
    };

    GearSketch.prototype.isChainStroked = function(stroke) {
      var chain, id, ref;
      ref = this.board.getChains();
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        chain = ref[id];
        if (chain.intersectsPath(stroke)) {
          return true;
        }
      }
      return false;
    };

    GearSketch.prototype.removeStrokedChains = function(stroke) {
      var chain, id, ref, results;
      ref = this.board.getChains();
      results = [];
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        chain = ref[id];
        if (chain.intersectsPath(stroke)) {
          results.push(this.board.removeChain(chain));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    GearSketch.prototype.processStroke = function() {
      var chain, gear, normalizedStroke;
      normalizedStroke = this.normalizeStroke(this.stroke);
      if (normalizedStroke.length >= 3) {
        if (Util.findGearsInsidePolygon(normalizedStroke, this.board.getGears()).length > 0) {
          chain = new Chain(normalizedStroke);
          this.board.addChain(chain);
        } else {
          gear = this.createGearFromStroke(normalizedStroke);
          if (gear != null) {
            if (this.board.addGear(gear) && !(gear.numberOfTeeth in this.gearImages)) {
              this.addGearImage(gear);
            }
          } else if (this.isChainStroked(normalizedStroke)) {
            this.removeStrokedChains(normalizedStroke);
          } else {
            this.removeStrokedGears(normalizedStroke);
          }
        }
      }
      return this.stroke = [];
    };

    GearSketch.prototype.calculateMomentumFromCoords = function(gear, x, y) {
      var angle, angleFromTop;
      angle = Math.atan2(y - gear.location.y, x - gear.location.x);
      angleFromTop = angle + 0.5 * Math.PI;
      if (angleFromTop < Math.PI) {
        return angleFromTop;
      } else {
        return angleFromTop - 2 * Math.PI;
      }
    };

    GearSketch.prototype.updateAndDraw = function() {
      return setTimeout(((function(_this) {
        return function() {
          requestAnimationFrame(_this.updateAndDraw);
          _this.update();
          return _this.draw();
        };
      })(this)), 1000 / FPS);
    };

    GearSketch.prototype.update = function() {
      var delta, updateTime;
      updateTime = new Date().getTime();
      delta = updateTime - this.lastUpdateTime;
      if (this.isPlaying) {
        this.board.rotateAllTurningObjects(delta);
      }
      if (this.isDemoPlaying) {
        this.updateDemo(delta);
      }
      return this.lastUpdateTime = updateTime;
    };

    GearSketch.prototype.drawGear = function(ctx, gear, color) {
      var angleStep, gearImage, i, innerPoints, j, k, l, numberOfTeeth, outerPoints, r, ref, ref1, ref2, ref3, ref4, rotation, x, y;
      if (color == null) {
        color = "black";
      }
      ref = gear.location, x = ref.x, y = ref.y;
      rotation = gear.rotation;
      numberOfTeeth = gear.numberOfTeeth;
      if (gear === this.selectedGear) {
        color = "green";
      }
      if (gear.id === ((ref1 = this.board.getInputGear()) != null ? ref1.id : void 0)) {
        color = "blue";
      }
      if (gear.id === ((ref2 = this.board.getOutputGear()) != null ? ref2.id : void 0)) {
        color = "violet";
      }
      gearImage = this.gearImages[gear.numberOfTeeth];
      if (color === "black" && (gearImage != null)) {
        gearImage = this.gearImages[gear.numberOfTeeth];
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.drawImage(gearImage, -0.5 * gearImage.width, -0.5 * gearImage.height);
        ctx.restore();
        return;
      }
      angleStep = 2 * Math.PI / numberOfTeeth;
      innerPoints = [];
      outerPoints = [];
      for (i = j = 0, ref3 = numberOfTeeth; 0 <= ref3 ? j < ref3 : j > ref3; i = 0 <= ref3 ? ++j : --j) {
        for (r = k = 0; k < 4; r = ++k) {
          if (r === 0 || r === 3) {
            innerPoints.push(Point.polar((i + 0.25 * r) * angleStep, gear.innerRadius));
          } else {
            outerPoints.push(Point.polar((i + 0.25 * r) * angleStep, gear.outerRadius));
          }
        }
      }
      ctx.save();
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.translate(x, y);
      ctx.rotate(rotation);
      ctx.beginPath();
      ctx.moveTo(gear.innerRadius, 0);
      for (i = l = 0, ref4 = numberOfTeeth * 2; 0 <= ref4 ? l < ref4 : l > ref4; i = 0 <= ref4 ? ++l : --l) {
        if (i % 2 === 0) {
          ctx.lineTo(innerPoints[i].x, innerPoints[i].y);
          ctx.lineTo(outerPoints[i].x, outerPoints[i].y);
        } else {
          ctx.lineTo(outerPoints[i].x, outerPoints[i].y);
          ctx.lineTo(innerPoints[i].x, innerPoints[i].y);
        }
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(AXIS_RADIUS, 0);
      ctx.arc(0, 0, AXIS_RADIUS, 0, 2 * Math.PI, true);
      ctx.closePath();
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(AXIS_RADIUS, 0);
      ctx.lineTo(gear.innerRadius, 0);
      ctx.closePath();
      ctx.stroke();
      return ctx.restore();
    };

    GearSketch.prototype.drawButton = function(ctx, button) {
      var height, padding, radius, ref, width, x, y;
      ref = button.location, x = ref.x, y = ref.y;
      padding = button.padding;
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      radius = 10;
      width = button.width + 2 * padding;
      height = button.height + 2 * padding;
      ctx.moveTo(radius, 0);
      ctx.lineTo(width - radius, 0);
      ctx.quadraticCurveTo(width, 0, width, radius);
      ctx.lineTo(width, height - radius);
      ctx.quadraticCurveTo(width, height, width - radius, height);
      ctx.lineTo(radius, height);
      ctx.quadraticCurveTo(0, height, 0, height - radius);
      ctx.lineTo(0, radius);
      ctx.quadraticCurveTo(0, 0, radius, 0);
      if (button.name === this.selectedButton) {
        ctx.fillStyle = "rgba(50, 150, 255, 0.8)";
      } else {
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
      }
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "black";
      ctx.stroke();
      ctx.drawImage(button, padding, padding);
      return ctx.restore();
    };

    GearSketch.prototype.drawMomentum = function(ctx, gear, momentum, color) {
      var angle, head, headX, headY, length, p1, p2, pitchRadius, sign, top;
      if (color == null) {
        color = "red";
      }
      pitchRadius = gear.pitchRadius;
      top = new Point(gear.location.x, gear.location.y - pitchRadius);
      ctx.save();
      ctx.lineWidth = 5;
      ctx.lineCap = "round";
      ctx.strokeStyle = color;
      ctx.translate(top.x, top.y);
      ctx.beginPath();
      ctx.arc(0, pitchRadius, pitchRadius, -0.5 * Math.PI, momentum - 0.5 * Math.PI, momentum < 0);
      ctx.stroke();
      length = 15;
      angle = 0.2 * Math.PI;
      headX = -Math.cos(momentum + 0.5 * Math.PI) * pitchRadius;
      headY = pitchRadius - Math.sin(momentum + 0.5 * Math.PI) * pitchRadius;
      head = new Point(headX, headY);
      sign = Util.sign(momentum);
      p1 = head.minus(Point.polar(momentum + angle, sign * length));
      ctx.beginPath();
      ctx.moveTo(headX, headY);
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      p2 = head.minus(Point.polar(momentum - angle, sign * length));
      ctx.beginPath();
      ctx.moveTo(headX, headY);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      return ctx.restore();
    };

    GearSketch.prototype.drawChain = function(ctx, chain) {
      var isCounterClockwise, j, k, len, len1, point, ref, ref1, segment;
      ctx.save();
      ctx.lineWidth = Chain.WIDTH;
      ctx.lineCap = "round";
      ctx.strokeStyle = "rgb(0, 0, 255)";
      ctx.moveTo(chain.segments[0].start.x, chain.segments[0].start.y);
      ref = chain.segments;
      for (j = 0, len = ref.length; j < len; j++) {
        segment = ref[j];
        if (segment instanceof ArcSegment) {
          isCounterClockwise = segment.direction === Util.Direction.COUNTER_CLOCKWISE;
          ctx.beginPath();
          ctx.arc(segment.center.x, segment.center.y, segment.radius, segment.startAngle, segment.endAngle, isCounterClockwise);
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(segment.start.x, segment.start.y);
          ctx.lineTo(segment.end.x, segment.end.y);
          ctx.stroke();
        }
      }
      ctx.fillStyle = "white";
      ref1 = chain.findPointsOnChain(25);
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        point = ref1[k];
        ctx.beginPath();
        ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI, true);
        ctx.fill();
      }
      return ctx.restore();
    };

    GearSketch.prototype.drawDemoPointer = function(ctx, location) {
      return ctx.drawImage(this.pointerImage, location.x - 0.5 * this.pointerImage.width, location.y);
    };

    GearSketch.prototype.draw = function() {
      var arrow, arrowsToDraw, buttonName, chain, ctx, gear, i, j, k, l, len, len1, m, momentum, ratio, ref, ref1, ref2, ref3, ref4, ref5, ref6, shouldDrawChainsAndArrows, sortedGears;
      if (this.canvas.getContext != null) {
        this.removePlusButton();
        ctx = this.canvas.getContext("2d");
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        sortedGears = this.board.getGearsSortedByGroupAndLevel();
        arrowsToDraw = [];
        for (i = j = 0, ref = sortedGears.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          gear = sortedGears[i];
          momentum = gear.momentum;
          if (gear === this.selectedGear && this.goalLocationGear) {
            this.drawGear(ctx, gear, "grey");
            if (momentum) {
              arrowsToDraw.push([gear, momentum, "grey"]);
            }
          } else {
            this.drawGear(ctx, gear);
            if (momentum) {
              arrowsToDraw.push([gear, momentum, "red"]);
            }
          }
          shouldDrawChainsAndArrows = (i === sortedGears.length - 1) || (this.board.getLevelScore(gear) !== this.board.getLevelScore(sortedGears[i + 1]));
          if (shouldDrawChainsAndArrows) {
            ref1 = this.board.getChainsInGroupOnLevel(gear.group, gear.level);
            for (k = 0, len = ref1.length; k < len; k++) {
              chain = ref1[k];
              this.drawChain(ctx, chain);
            }
            for (l = 0, len1 = arrowsToDraw.length; l < len1; l++) {
              arrow = arrowsToDraw[l];
              this.drawMomentum(ctx, arrow[0], arrow[1], arrow[2]);
            }
            arrowsToDraw = [];
          }
        }
        if (this.goalLocationGear) {
          this.drawGear(ctx, this.goalLocationGear, "red");
        }
        if ((this.selectedGear != null) && this.selectedGearMomentum) {
          this.drawMomentum(ctx, this.selectedGear, this.selectedGearMomentum);
        }
        if (this.stroke.length > 0) {
          ctx.save();
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.stroke[0].x, this.stroke[0].y);
          for (i = m = 1, ref2 = this.stroke.length; 1 <= ref2 ? m < ref2 : m > ref2; i = 1 <= ref2 ? ++m : --m) {
            ctx.lineTo(this.stroke[i].x, this.stroke[i].y);
          }
          ctx.stroke();
          ctx.restore();
        }
        if (this.isDrawingMenu) {
          this.drawMenu(ctx, this.selectedGear);
        } else if (this.selectedGear != null) {
          this.drawPlusButton(this.selectedGear);
        }
        if (this.areButtonsLoaded && this.shouldShowButtons()) {
          ref3 = this.buttons;
          for (buttonName in ref3) {
            if (!hasProp.call(ref3, buttonName)) continue;
            this.drawButton(ctx, this.buttons[buttonName]);
          }
        }
        if (this.message.length > 0) {
          ctx.save();
          ctx.fillStyle = this.messageColor;
          ctx.font = "bold 20px Arial";
          ctx.fillText(this.message, 20, 120);
          ctx.restore();
        }
        if (((ref4 = this.game) != null ? ref4.title.length : void 0) > 0) {
          ctx.save();
          ctx.fillStyle = this.messageColor;
          ctx.font = "bold 32px Arial";
          ctx.fillText(this.game.title, 200, 50);
          ctx.restore();
        }
        ratio = ((ref5 = this.board.getOutputGear()) != null ? ref5.rpm : void 0) / ((ref6 = this.board.getInputGear()) != null ? ref6.rpm : void 0);
        if (typeof ratio === 'number' && !isNaN(ratio)) {
          ctx.save();
          ctx.fillStyle = this.messageColor;
          ctx.font = "bold 20px Arial";
          ctx.fillText('I= ' + ratio, this.canvas.width - 250, 120);
          ctx.restore();
        }
        if (this.isDemoPlaying && this.pointerImage) {
          return this.drawDemoPointer(ctx, this.pointerLocation);
        }
      }
    };

    GearSketch.prototype.updateCanvasSize = function() {
      var initialX;
      this.canvas.width = this.canvas.parentElement.getBoundingClientRect().width;
      this.canvas.height = this.canvas.parentElement.getBoundingClientRect().height;
      initialX = 400;
      if (this.simpleMenu) {
        initialX = 320;
      }
      this.buttons["playButton"].location.x = this.buttons["backButton"].location.x + 80;
      this.buttons["selectInputGear"].location.x = Math.max(this.canvas.width - initialX, this.buttons["backButton"].location.x + 80);
      this.buttons["selectOutputGear"].location.x = this.buttons["selectInputGear"].location.x + 80;
      this.buttons["showFormulas"].location.x = this.buttons["selectOutputGear"].location.x + 80;
      this.buttons["helpButton"].location.x = this.buttons["showFormulas"].location.x + 80;
      if (!this.simpleMenu) {
        this.buttons["showObjectives"].location.x = this.buttons["showFormulas"].location.x + 80;
        this.buttons["tryVerify"].location.x = Math.max(this.buttons["backButton"].location.x, this.canvas.width - 181);
        this.buttons["tryVerify"].location.y = this.canvas.height - 80;
        return this.buttons["helpButton"].location.x = this.buttons["showObjectives"].location.x + 80;
      }
    };

    GearSketch.prototype.loadDemoMovements = function() {
      return this.demoMovements = [
        {
          from: this.getButtonCenter("helpButton"),
          to: new Point(400, 200),
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.CIRCLE,
          radius: 100,
          duration: 1500
        }, {
          to: new Point(600, 200),
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.CIRCLE,
          radius: 40,
          duration: 1000
        }, {
          to: new Point(600, 240),
          type: MovementType.STRAIGHT,
          duration: 500
        }, {
          to: new Point(400, 300),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          to: new Point(200, 180),
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.CIRCLE,
          radius: 90,
          duration: 1000
        }, {
          to: new Point(200, 260),
          type: MovementType.STRAIGHT,
          duration: 500
        }, {
          to: new Point(280, 260),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          to: new Point(650, 220),
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.CIRCLE,
          radius: 80,
          duration: 1000
        }, {
          to: new Point(380, 150),
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          atStart: MovementAction.PEN_DOWN,
          type: MovementType.LEFT_HALF_CIRCLE,
          radius: 140,
          duration: 1500,
          pause: 0
        }, {
          to: new Point(700, 400),
          type: MovementType.STRAIGHT,
          duration: 1000,
          pause: 0
        }, {
          type: MovementType.RIGHT_HALF_CIRCLE,
          radius: 110,
          duration: 1000,
          pause: 0
        }, {
          to: new Point(380, 150),
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: new Point(285, 180),
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          to: new Point(250, 190),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: this.getButtonCenter("playButton"),
          atEnd: MovementAction.PEN_TAP,
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: new Point(525, 250),
          type: MovementType.STRAIGHT,
          duration: 3000
        }, {
          to: new Point(625, 150),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: new Point(120, 250),
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: new Point(750, 300),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1500
        }, {
          to: new Point(525, 200),
          type: MovementType.STRAIGHT,
          duration: 1000
        }, {
          to: new Point(300, 400),
          atStart: MovementAction.PEN_DOWN,
          atEnd: MovementAction.PEN_UP,
          type: MovementType.STRAIGHT,
          duration: 1500
        }
      ];
    };

    GearSketch.prototype.getButtonCenter = function(buttonName) {
      var button, buttonCorner;
      button = this.buttons[buttonName];
      buttonCorner = new Point(button.location.x, button.location.y);
      return buttonCorner.plus(new Point(0.5 * button.width + button.padding, 0.5 * button.height + button.padding));
    };

    GearSketch.prototype.updateDemo = function(delta) {
      var movement;
      if (this.restTimer > 0) {
        this.restTimer = Math.max(this.restTimer - delta, 0);
        return;
      } else if (this.currentDemoMovement === this.demoMovements.length) {
        this.stopDemo();
        return;
      }
      movement = this.demoMovements[this.currentDemoMovement];
      if (this.movementCompletion === 0) {
        if (movement.from == null) {
          movement.from = this.pointerLocation;
        }
        if (movement.pause == null) {
          movement.pause = 500;
        }
        this.pointerLocation = movement.from.clone();
        if (movement.atStart === MovementAction.PEN_DOWN) {
          this.handlePenDown(this.pointerLocation.x, this.pointerLocation.y);
        }
      }
      if (this.movementCompletion < 1) {
        this.movementCompletion = Math.min(1, this.movementCompletion + delta / movement.duration);
        this.updatePointerLocation(movement, this.movementCompletion);
        this.handlePenMove(this.pointerLocation.x, this.pointerLocation.y);
      }
      if (this.movementCompletion === 1) {
        if (movement.atEnd === MovementAction.PEN_TAP) {
          this.handlePenDown(this.pointerLocation.x, this.pointerLocation.y);
          this.handlePenUp();
        } else if (movement.atEnd === MovementAction.PEN_UP) {
          this.handlePenUp();
        }
        this.restTimer = movement.pause;
        this.movementCompletion = 0;
        return this.currentDemoMovement++;
      }
    };

    GearSketch.prototype.updatePointerLocation = function(movement, movementCompletion) {
      var angle, center, delta;
      if (movement.type === MovementType.STRAIGHT) {
        delta = movement.to.minus(movement.from);
        return this.pointerLocation = movement.from.plus(delta.times(movementCompletion));
      } else if (movement.type === MovementType.CIRCLE) {
        center = new Point(movement.from.x, movement.from.y + movement.radius);
        return this.pointerLocation = center.plus(Point.polar(Math.PI - (movementCompletion - 0.25) * 2 * Math.PI, movement.radius));
      } else if (movement.type === MovementType.LEFT_HALF_CIRCLE) {
        center = new Point(movement.from.x, movement.from.y + movement.radius);
        angle = 1.5 * Math.PI - movementCompletion * Math.PI;
        return this.pointerLocation = center.plus(Point.polar(angle, movement.radius));
      } else if (movement.type === MovementType.RIGHT_HALF_CIRCLE) {
        center = new Point(movement.from.x, movement.from.y - movement.radius);
        angle = 0.5 * Math.PI - movementCompletion * Math.PI;
        return this.pointerLocation = center.plus(Point.polar(angle, movement.radius));
      }
    };

    GearSketch.prototype.playDemo = function() {
      this.loadDemoMovements();
      this.boardBackup = this.board.clone();
      this.board.clear();
      this.currentDemoMovement = 0;
      this.movementCompletion = 0;
      this.isDemoPlaying = true;
      return this.displayMessage("click anywhere to stop the demo");
    };

    GearSketch.prototype.stopDemo = function() {
      this.isDemoPlaying = false;
      this.restTimer = 0;
      this.stroke = [];
      this.selectedGear = null;
      this.selectedIcon = "gearIcon";
      this.board.restoreAfterDemo(this.boardBackup);
      return this.clearMessage();
    };

    GearSketch.prototype.boardUploaded = function(event) {
      return this.displayMessage("Board saved. Share it by copying the text in your address bar.", "black", 4000);
    };

    GearSketch.prototype.uploadBoard = function() {
      var boardJSON;
      boardJSON = JSON.stringify(this.game);
      return Util.sendPostRequest(boardJSON, "upload_board.php", ((function(_this) {
        return function(event) {
          return _this.boardUploaded(event);
        };
      })(this)));
    };

    GearSketch.prototype.addTeeth = function(gear) {
      this.board.removeGear(gear);
      gear.numberOfTeeth = gear.numberOfTeeth + 1;
      gear = Gear.fromObject(gear);
      this.selectedGear = gear;
      if (this.board.addGear(gear) && !(gear.numberOfTeeth in this.gearImages)) {
        return this.addGearImage(gear);
      }
    };

    GearSketch.prototype.removeTeeth = function(gear) {
      if (gear.numberOfTeeth > 6) {
        this.board.removeGear(gear);
        gear.numberOfTeeth = gear.numberOfTeeth - 1;
        gear = Gear.fromObject(gear);
        this.selectedGear = gear;
        if (this.board.addGear(gear) && !(gear.numberOfTeeth in this.gearImages)) {
          return this.addGearImage(gear);
        }
      }
    };

    GearSketch.prototype.setRPM = function(rpm) {
      return this.selectedGear.momentum = rpm * 2 * Math.PI / 60;
    };

    GearSketch.prototype.rpmUp = function(gear) {
      return gear.momentum += this.rpmToMomentum(1);
    };

    GearSketch.prototype.rpmDown = function(gear) {
      return gear.momentum -= this.rpmToMomentum(1);
    };

    GearSketch.prototype.momentumToRPM = function(momentum) {
      return momentum * 60 / (2 * Math.PI);
    };

    GearSketch.prototype.rpmToMomentum = function(rpm) {
      return rpm * (2 * Math.PI) / 60;
    };

    GearSketch.prototype.selectInputGear = function() {
      return this.board.setInputGear(this.selectedGear);
    };

    GearSketch.prototype.selectOutputGear = function() {
      return this.board.setOutputGear(this.selectedGear);
    };

    GearSketch.prototype.showFormulasModal = function() {
      return $('#formulasModal').modal('toggle');
    };

    GearSketch.prototype.showObjectivesModal = function() {
      return $('#objectivesModal').modal('toggle');
    };

    GearSketch.prototype.showSubmitAnswerModal = function() {
      return $('#submitAnswerModal').modal('toggle');
    };

    GearSketch.prototype.showBackConfirmationModal = function() {
      return $('#backConfirmationModal').modal('toggle');
    };

    GearSketch.prototype.loadGameMenus = function(game) {
      var id, input, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results;
      $('#objectivesModal .modal-title').html((ref = game.modals) != null ? (ref1 = ref.objectives) != null ? ref1.header : void 0 : void 0);
      $('#objectivesModal .modal-body').html((ref2 = game.modals) != null ? (ref3 = ref2.objectives) != null ? ref3.body : void 0 : void 0);
      if ((ref4 = game.modals) != null ? (ref5 = ref4.objectives) != null ? ref5.body : void 0 : void 0) {
        $('#objectivesModal').modal('toggle');
      }
      $('#somethingWentWrong .modal-title').html((ref6 = game.modals) != null ? (ref7 = ref6.validationError) != null ? ref7.header : void 0 : void 0);
      $('#somethingWentWrong .modal-body').html((ref8 = game.modals) != null ? (ref9 = ref8.validationError) != null ? ref9.body : void 0 : void 0);
      $('#validationsPassed .modal-title').html((ref10 = game.modals) != null ? (ref11 = ref10.validationPassed) != null ? ref11.header : void 0 : void 0);
      $('#validationsPassed .modal-body').html((ref12 = game.modals) != null ? (ref13 = ref12.validationPassed) != null ? ref13.body : void 0 : void 0);
      $('#backConfirmationModal .modal-title').html((ref14 = game.modals) != null ? (ref15 = ref14.backToMenu) != null ? ref15.header : void 0 : void 0);
      $('#backConfirmationModal .modal-body').html((ref16 = game.modals) != null ? (ref17 = ref16.backToMenu) != null ? ref17.body : void 0 : void 0);
      if (((ref18 = game.modals) != null ? (ref19 = ref18.backToMenu) != null ? ref19.performAction : void 0 : void 0)) {
        $('#backConfirmationModal .btn-danger').html((ref20 = game.modals) != null ? (ref21 = ref20.backToMenu) != null ? ref21.performAction : void 0 : void 0);
      }
      $('#submitAnswerModal .modal-title').html((ref22 = game.modals) != null ? (ref23 = ref22.objectives) != null ? ref23.header : void 0 : void 0);
      $('#submitAnswerModal .form-horizontal').append((ref24 = game.modals) != null ? (ref25 = ref24.validate) != null ? ref25.body : void 0 : void 0);
      ref26 = game.inputs;
      results = [];
      for (id in ref26) {
        input = ref26[id];
        results.push($('#submitAnswerModal .form-horizontal').append(this.createField(input)));
      }
      return results;
    };

    GearSketch.prototype.createField = function(input) {
      var j, len, option, ref, ref1, ref2, ref3, ref4, ref5, ref6, ret;
      ret = "";
      if (((ref = input.properties) != null ? ref.objective : void 0) != null) {
        ret = "<div class=\"col-sm-12\">\n<p class=\"form-control-static\">" + input.properties.objective + "</p>\n</div><br/>";
      }
      if (((ref1 = input.properties) != null ? ref1.beforeInputText : void 0) != null) {
        ret += "<label for='" + input.id + "'  class=\"col-sm-3 control-label\">" + ((ref2 = input.properties) != null ? ref2.beforeInputText : void 0) + "</label>";
      }
      if (input.inputType === "radio") {
        ret += "<div class=\"col-sm-12\" >";
        ref4 = (ref3 = input.properties) != null ? ref3.options : void 0;
        for (j = 0, len = ref4.length; j < len; j++) {
          option = ref4[j];
          ret += "<div class=\"radio\">\n          <label><input type=\"radio\" name=\"" + input.id + "\" value=\"" + option + "\" class=\"radio\" />" + option + "</label>\n</div>";
        }
        ret += "</div>";
      } else {
        ret += "<div class=\"col-sm-7\">\n<input id='" + input.id + "' type=\"text\" class=\"form-control\" placeholder=\"Text input\"/>\n</div>";
      }
      if (((ref5 = input.properties) != null ? ref5.afterInputText : void 0) != null) {
        ret += "  <label for='" + input.id + "' class=\"col-sm-1 control-label\">" + ((ref6 = input.properties) != null ? ref6.afterInputText : void 0) + "</label>\n<div class=\"col-sm-1\"/>";
      }
      ret = "  <div class=\"form-group\">" + ret + "</div> ";
      return ret;
    };

    GearSketch.prototype.verify = function() {
      var currTime, elapsedTime, input, j, k, len, len1, passed, ref, ref1, result;
      ref = $('#inputs .form-control');
      for (j = 0, len = ref.length; j < len; j++) {
        input = ref[j];
        this.game.inputs[input.id].actualValue = input.value;
      }
      ref1 = $('#inputs .radio:checked');
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        input = ref1[k];
        this.game.inputs[input.name].actualValue = input.value;
      }
      passed = this.game.validate();
      currTime = new Date().getTime();
      elapsedTime = currTime - this.initTime;
      result = new ValidationResult(this.game.level, this.game.key, elapsedTime / 1000, passed);
      Util.sendPostRequest(JSON.stringify(result), "/verify");
      if (passed) {
        return $('#validationsPassed').modal('toggle');
      } else {
        return $('#somethingWentWrong').modal('toggle');
      }
    };

    MENU_BUTTONS = [["addTeethButton", "zup.png", [-125, -120]], ["removeTeethButton", "zdown.png", [125, -120]], ["rpmUpButton", "momentumUp.png", [-125, -40]], ["rpmDownButton", "momentumDown.png", [125, -40]]];

    HIDDEN_MENU_BUTTONS = [["drawMenuButton", "menu.png"]];

    GearSketch.prototype.removeMenu = function() {
      var file, j, len, name, ref, results;
      results = [];
      for (j = 0, len = MENU_BUTTONS.length; j < len; j++) {
        ref = MENU_BUTTONS[j], name = ref[0], file = ref[1];
        results.push(delete this.buttons[name]);
      }
      return results;
    };

    GearSketch.prototype.removePlusButton = function() {
      return delete this.buttons["drawMenuButton"];
    };

    GearSketch.prototype.drawPlusButton = function(gear) {
      var button, file, i, j, len, name, radius, ref, ref1, results, x, y;
      ref = gear.location, x = ref.x, y = ref.y;
      radius = gear.pitchRadius;
      results = [];
      for (i = j = 0, len = HIDDEN_MENU_BUTTONS.length; j < len; i = ++j) {
        ref1 = HIDDEN_MENU_BUTTONS[i], name = ref1[0], file = ref1[1];
        button = new Image();
        button.name = name;
        button.padding = 3;
        button.src = "img/" + file;
        button.location = new Point(x + radius, y - radius);
        results.push(this.buttons[name] = button);
      }
      return results;
    };

    GearSketch.prototype.loadMenuButtons = function(location, width, height) {
      var bWith, button, file, i, j, len, name, ref, ref1, results, x, xx, xxx, y, yy, yyy;
      x = location.x, y = location.y;
      results = [];
      for (i = j = 0, len = MENU_BUTTONS.length; j < len; i = ++j) {
        ref = MENU_BUTTONS[i], name = ref[0], file = ref[1], (ref1 = ref[2], xx = ref1[0], yy = ref1[1]);
        button = new Image();
        button.name = name;
        button.padding = 3;
        button.src = "img/" + file;
        xxx = modulo(i, 2) ? x - width / 2 + 6 : x + width / 2 - button.width - 11;
        bWith = (2 * button.padding) + button.width / 2;
        yyy = (6 - bWith + y - height) + ((2 * bWith) * Math.floor(i / 2));
        button.location = new Point(xxx, yyy);
        results.push(this.buttons[name] = button);
      }
      return results;
    };

    GearSketch.prototype.drawMenu = function(ctx, gear) {
      var height, myY, radius, ref, width, x, y;
      this.removePlusButton();
      ref = gear.location, x = ref.x, y = ref.y;
      width = 250;
      height = 217;
      radius = 10;
      ctx.save();
      ctx.translate(x - width / 2, y - 20 - height);
      ctx.beginPath();
      ctx.moveTo(radius, 0);
      ctx.lineTo(width - radius, 0);
      ctx.quadraticCurveTo(width, 0, width, radius);
      ctx.lineTo(width, height - radius);
      ctx.quadraticCurveTo(width, height, width - radius, height);
      ctx.lineTo(radius, height);
      ctx.quadraticCurveTo(0, height, 0, height - radius);
      ctx.lineTo(0, radius);
      ctx.quadraticCurveTo(0, 0, radius, 0);
      ctx.lineWidth = 3;
      ctx.fillStyle = "white";
      ctx.fill();
      ctx.fillStyle = "black";
      ctx.font = "bold 16px Arial";
      ctx.fillText("Z=" + gear.numberOfTeeth, 100, 40);
      ctx.fillText("M=" + Math.round(gear.momentum * 100) / 100, 100, 120);
      myY = 160;
      ctx.fillText("-----------------", 80, myY);
      myY += 20;
      ctx.fillText("r=" + gear.pitchRadius, 100, myY);
      myY += 20;
      ctx.fillText("n=" + Math.round(gear.rpm * 100) / 100, 100, myY);
      ctx.strokeStyle = "black";
      ctx.stroke();
      ctx.restore();
      return this.loadMenuButtons(gear.location, width, height - 20);
    };

    window.gearsketch.GearSketch = GearSketch;

    return GearSketch;

  })();

}).call(this);

//# sourceMappingURL=gearsketch_main.js.map
